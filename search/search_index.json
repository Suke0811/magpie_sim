{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Multi-Modal End-Effector","text":""},{"location":"#mechanisms-and-computational-design-of-multi-modal-end-effector-with-force-sensing-using-gated-networks","title":"Mechanisms and Computational Design of Multi-Modal End-Effector with Force Sensing using Gated Networks","text":"<p>For the source code, visit our github repo in the top right</p>"},{"location":"md/api/apis/","title":"MAGPIE Sensor Mechanisms Simulation APIs","text":"Warning <p>All api docs are auto-generated and refernce only</p>"},{"location":"md/api/apis/#how-to-use-the-beamsensortrajectory-and-magnetsensorsimulation-classes","title":"How to Use the <code>BeamSensorTrajectory</code> and <code>MagnetSensorSimulation</code> Classes","text":"<p>This guide explains how to use the <code>BeamSensorTrajectory</code> class in conjunction with the <code>MagnetSensorSimulation</code> class for simulating beam and magnetic sensor interactions.  The example provided runs a full simulation of sensor and magnet trajectories using beam deformation models and magnet configurations.</p> <p>For the APIs, please see the following links. </p> <p>Beam Deformation</p><p>\u2022 Von Karaman Beam Solver  \u2022 Beam deformation in \\(x\\), \\(y\\) and \\(\\theta\\)</p> <p>Magnetic Simulation</p><p>\u2022 Magnetic field simulation  \u2022 Sensor plots  \u2022 stream plots</p> <p>Trajectory Generator</p><p>\u2022 handle sequential trajectory generation</p>"},{"location":"md/api/apis/#prerequisites","title":"Prerequisites","text":"<p>Before running the code, make sure you have the following packages installed: <pre><code>pip install -r requirements.txt\n</code></pre></p>"},{"location":"md/api/apis/#example-usage","title":"Example Usage","text":"<ol> <li> <p>Define Sensor and Magnet Beam Configurations    To begin, define the configurations for both the sensor beam and magnet beam using dictionaries. You can also load these from YAML files if desired. In this example, both configurations are passed directly as dictionaries.</p> <pre><code>sensor_beam_config = {\n    'P': 350,  # Maximum load in Newtons\n    'L': 30,  # Length of the beam in mm\n    'E': 72000,  # Young's Modulus in MPa\n    'b': 11.5,  # Width of the beam in mm\n    'h': 4.5,  # Thickness of the beam in mm\n    'point_offset': 5.5,  # Offset from the center of the beam in mm\n    'kappa': 0.833,  # Shear correction factor\n    'poisson_ratio': 0.33,  # Poisson's ratio of the material\n    'time_steps': 10  # Number of time steps for force increment\n}\n\nmagnet_beam_config = {\n    'P': 350,\n    'L': 30,\n    'E': 72000,\n    'b': 11.5,\n    'h': 4.5,\n    'point_offset': 5.5,\n    'kappa': 0.833,\n    'poisson_ratio': 0.33,\n    'time_steps': 10\n}\n</code></pre> </li> <li> <p>Initialize the Simulation    Create an instance of the <code>MagnetSensorSimulation</code> class and add the sensor and magnet to the simulation. You can specify sensor pixel coordinates, positions, orientations, and load STL files to represent the sensor and magnet geometries.</p> <pre><code>simulation = MagnetSensorSimulation()\n\n# Add a sensor to the simulation\nsimulation.add_sensor(\n    sensor_pixels=[(0, 0, 0)],  # Sensor pixel configuration\n    sensor_position=[0, 0, 0],  # Position of the sensor\n    stl_file='model/A31301EEJASR-XYZ-IC-20.stl',  # STL model for the sensor\n    stl_offset=[0, 0, -0.0008]  # Offset for the sensor STL model\n)\n\n# Add a magnet to the simulation\nsimulation.add_magnet(\n    shape=\"cylinder\",  # Magnet shape (cylinder)\n    polarization=(0, 0, -1),  # Polarization direction of the magnet\n    dimension=(0.003, 0.002),  # Dimensions of the magnet (in meters)\n    position=[0, 0, 0.0015 + 0.001],  # Position of the magnet\n    style_magnetization={\n        'color': {'north': '#00FFFF', 'south': '#00008B', 'middle': '#FFFFFF', 'mode': 'tricolor'}\n    }\n)\n</code></pre> </li> <li> <p>Create the Beam and Magnet Trajectories    Create an instance of the <code>BeamSensorTrajectory</code> class, which generates sensor and magnet trajectories based on the provided beam configurations.</p> <pre><code>trajectory_generator = BeamSensorTrajectory(\n    sensor_beam_config,  # Beam configuration for the sensor\n    magnet_beam_config,  # Beam configuration for the magnet\n    simulation,  # Simulation instance\n    frame_translation=[0, 0, 0.03]  # Translation of the frame\n)\n</code></pre> </li> <li> <p>Run the Simulation    Call the <code>run_simulation</code> method of the <code>BeamSensorTrajectory</code> instance to run the full simulation. You can also specify a path to save the results of the simulation.</p> <pre><code>trajectory_generator.run_simulation(save_as='out1/mag1')\n</code></pre> </li> </ol>"},{"location":"md/api/apis/#methods","title":"Methods","text":"<ul> <li><code>add_sensor()</code>: Adds a sensor to the simulation with the option to load an STL file for 3D visualization.</li> <li><code>add_magnet()</code>: Adds a magnet to the simulation. You can specify the magnet's shape (e.g., cylinder, cube), polarization, and position.</li> <li><code>create_sensor_trajectory()</code>: Generates the sensor trajectory based on beam deformation, which includes sensor positions and orientations.</li> <li><code>create_magnet_trajectory()</code>: Similar to <code>create_sensor_trajectory</code>, this generates the magnet's trajectory based on the magnet beam deformation model.</li> <li><code>run_simulation()</code>: Runs the full simulation, applying sensor and magnet trajectories, displaying the results, and computing sensitivity data. You can optionally save the results to files.</li> </ul>"},{"location":"md/api/apis/#output-and-visualization","title":"Output and Visualization","text":""},{"location":"md/api/apis/#plotting-sensor-and-magnet-trajectories","title":"Plotting Sensor and Magnet Trajectories","text":"<p>The <code>plot_trajectories_2d()</code> method creates a 2D plot of sensor and magnet positions and orientations over time. You can save the plot as an HTML file or display it directly in the browser.</p> <pre><code>trajectory_generator.plot_trajectories_2d(sensor_positions, magnet_positions, sensor_orientations, magnet_orientations)\n</code></pre>"},{"location":"md/api/apis/#saving-results-to-csv","title":"Saving Results to CSV","text":"<p>You can save the computed sensor and magnet positions, orientations, and magnetic field data to a CSV file using the save_results_to_csv() method. <pre><code>trajectory_generator.save_results_to_csv(sensor_positions, sensor_orientations, magnet_positions, magnet_orientations, file_name=\"output.csv\")\n</code></pre></p>"},{"location":"md/api/apis/#sensitivity-computation","title":"Sensitivity Computation","text":"<p>The compute_sensitivity() method calculates the sensitivity (rate of change of the magnetic field with respect to applied forces) and plots the results. You can also save the plot to an HTML file.</p> <pre><code>trajectory_generator.compute_sensitivity(applied_forces=[0, 100, 200], file_path=\"sensitivity_plot.html\")\n</code></pre>"},{"location":"md/api/beam/","title":"Von Karaman Beam Solver","text":"<p>Class to solve the von Karman beam bending problem using numerical methods.</p> Source code in <code>lib/BeamModel.py</code> <pre><code>class VonKarmanBeamSolver:\n    \"\"\"\n    Class to solve the von Karman beam bending problem using numerical methods.\n    \"\"\"\n\n    def __init__(self, P, L, E, b, h, point_offset, time_steps=100, kappa=5/6, poisson_ratio=0.33, yield_strength=250, fatigue_strength=160):\n        \"\"\"\n        Initializes the Von Karman Beam Solver.\n\n        Args:\n            P (float): Maximum load in Newtons.\n            L (float): Length of the beam in mm.\n            E (float): Young's Modulus in MPa (N/mm^2).\n            b (float): Width of the beam in mm.\n            h (float): Thickness of the beam in mm.\n            point_offset (float): Offset from the center of the beam in mm.\n            time_steps (int, optional): Number of time steps for force increase. Defaults to 100.\n            kappa (float, optional): Shear correction factor. Defaults to 5/6.\n            poisson_ratio (float, optional): Poisson's ratio of the material. Defaults to 0.33.\n            yield_strength (float, optional): Yield strength of the material in MPa. Defaults to 250 MPa.\n            fatigue_strength (float, optional): Fatigue strength of the material at 1e7 cycles in MPa. Defaults to 160 MPa.\n        \"\"\"\n        self.P_max = P\n        self.L = L\n        self.E = E\n        self.G = E / (2 * (1 + poisson_ratio))  # Shear modulus\n        self.b = b\n        self.h = h\n        self.point_offset = point_offset\n        self.kappa = kappa\n        self.time_steps = time_steps\n        self.yield_strength = yield_strength\n        self.fatigue_strength = fatigue_strength\n\n        # Cross-sectional properties\n        self.I = (b * h ** 3) / 12  # Second moment of area for rectangular cross-section\n        self.A = b * h  # Cross-sectional area\n\n        # Initialize safety factor lists\n        self.safety_factors_yield = []  # List to store safety factors for yield strength\n        self.safety_factors_fatigue = []  # List to store safety factors for fatigue strength\n\n        # Variables to store forces at which safety factors fall below 2\n        self.force_below_yield_sf = None\n        self.force_below_fatigue_sf = None\n\n    @classmethod\n    def from_yaml(cls, yaml_file):\n        \"\"\"\n        Load parameters from a YAML file and initialize the class.\n\n        Args:\n            yaml_file (str): Path to the YAML file containing beam configuration parameters.\n\n        Returns:\n            VonKarmanBeamSolver: Instance of the VonKarmanBeamSolver class.\n        \"\"\"\n        with open(yaml_file, 'r') as file:\n            data = yaml.safe_load(file)\n        return cls(\n            P=data['P'],\n            L=data['L'],\n            E=data['E'],\n            b=data['b'],\n            h=data['h'],\n            point_offset=data['point_offset'],\n            time_steps=data.get('time_steps', 100),\n            kappa=data.get('kappa', 5 / 6),\n            poisson_ratio=data.get('poisson_ratio', 0.33)\n        )\n\n    def von_karman_beam(self, t, y, P):\n        \"\"\"\n        Differential equation for Von Karman beam bending.\n\n        Args:\n            t (float): Position along the beam.\n            y (list of float): State vector [deflection, slope, horizontal displacement].\n            P (float): Applied load at the current time step.\n\n        Returns:\n            list of float: List of derivatives [dw/dx, d\u00b2w/dx\u00b2, du/dx].\n        \"\"\"\n        w, dw_dx, u = y  # Deflection, slope, and horizontal displacement\n        d2w_dx2 = (P * (self.L - t)) / (self.E * self.I)  # Curvature\n        du_dx = 0.5 * (dw_dx ** 2)  # Horizontal stretch\n        return [dw_dx, d2w_dx2, du_dx]\n\n    def solve(self, save_path=None):\n        \"\"\"\n        Solve the beam equations using numerical integration.\n\n        Args:\n            save_path (str, optional): Path to save the results as a CSV file. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        y0 = [0, 0, 0]  # Initial conditions: w(0) = 0, slope = 0, u(0) = 0\n        t_eval = np.linspace(0, self.L, 100)  # Evaluation points along the beam\n\n        # Store solutions for each time step where the force P increases linearly\n        self.solutions = []\n        self.applied_force = []\n\n        # Solve for t=0 with no force\n        sol_initial = solve_ivp(self.von_karman_beam, [0, self.L], y0, t_eval=t_eval, args=(0,))\n        self.solutions.append(sol_initial)\n\n        # Solve for subsequent timesteps where force increases linearly\n        for t_step in range(1, self.time_steps + 1):\n            P_current = self.P_max * (t_step / self.time_steps)  # Linearly increase force\n            self.applied_force.append(P_current)\n            sol = solve_ivp(self.von_karman_beam, [0, self.L], y0, t_eval=t_eval, args=(P_current,))\n            self.solutions.append(sol)\n\n            # Calculate yield and fatigue safety factors\n            yield_sf = self.calculate_safety_factor(P_current)\n            fatigue_sf = self.calculate_fatigue_safety_factor(P_current)\n            self.safety_factors_yield.append(yield_sf)\n            self.safety_factors_fatigue.append(fatigue_sf)\n\n            # Record the force when safety factors fall below 2\n            if yield_sf &lt; 2 and self.force_below_yield_sf is None:\n                self.force_below_yield_sf = P_current\n\n            if fatigue_sf &lt; 2 and self.force_below_fatigue_sf is None:\n                self.force_below_fatigue_sf = P_current\n\n        # Extract the final solution for plotting and saving\n        final_solution = self.solutions[-1]\n        self.x = final_solution.t  # Position along the beam\n        self.w = final_solution.y[0]  # Vertical deflection\n        self.u = final_solution.y[2]  # Horizontal displacement\n        self.slope = final_solution.y[1]  # Slope (dw/dx)\n        self.angle = np.degrees(self.slope)  # Slope in degrees\n\n        # Calculate total displacements\n        self.u_total = self.u + self.point_offset * np.sin(self.slope)\n        self.w_total = self.w + self.point_offset * (1 - np.cos(self.slope))\n\n        if save_path:\n            # Save data to a CSV file for the final time step\n            data = {\n                'Position (x)': self.x,\n                'Vertical Deflection (w)': self.w_total,\n                'Horizontal Displacement (u)': self.u_total,\n                'Angle of Slope (degrees)': self.angle,\n                'Safety Factor (Yield)': self.safety_factors_yield[-1],\n                'Safety Factor (Fatigue)': self.safety_factors_fatigue[-1]\n            }\n            df = pd.DataFrame(data)\n            df.to_csv(save_path, index=False)\n            print(f\"Data saved to {save_path}\")\n\n    def calculate_safety_factor(self, P):\n        \"\"\"\n        Calculate the safety factor for yielding in bending.\n\n        Args:\n            P (float): Current applied load in Newtons.\n\n        Returns:\n            float: Safety factor for bending.\n        \"\"\"\n        M_max = P * self.L / 4  # Maximum bending moment\n        c = self.h / 2  # Distance from neutral axis to outermost fiber\n        sigma_max = (M_max * c) / self.I  # Maximum stress in bending\n        safety_factor = self.yield_strength / sigma_max\n        return safety_factor\n\n    def calculate_fatigue_safety_factor(self, P):\n        \"\"\"\n        Calculate the safety factor for fatigue at 1e7 cycles.\n\n        Args:\n            P (float): Current applied load in Newtons.\n\n        Returns:\n            float: Safety factor for fatigue.\n        \"\"\"\n        M_max = P * self.L / 4  # Maximum bending moment\n        c = self.h / 2  # Distance from neutral axis to outermost fiber\n        sigma_max = (M_max * c) / self.I  # Maximum bending stress\n        safety_factor_fatigue = self.fatigue_strength / sigma_max\n        return safety_factor_fatigue\n\n    def plot(self, save_path=None):\n        \"\"\"\n        Generate an interactive plot using Plotly to visualize beam deflection and slope.\n\n        Args:\n            save_path (str, optional): Path to save the plot as an HTML file. Defaults to None.\n\n        Returns:\n            None\n        \"\"\"\n        fig = go.Figure()\n\n        # Horizontal movement trace\n        fig.add_trace(go.Scatter(x=self.x, y=self.u_total, mode='lines', name='Horizontal Movement (u)',\n                                 line=dict(color='blue')))\n\n        # Vertical movement trace\n        fig.add_trace(go.Scatter(x=self.x, y=self.w_total, mode='lines', name='Vertical Movement (w)',\n                                 line=dict(color='red', dash='dash')))\n\n        # Angle trace\n        fig.add_trace(go.Scatter(x=self.x, y=self.angle, mode='lines', name='Angle of Slope (degrees)',\n                                 line=dict(color='green', dash='dot')))\n\n        # Layout settings\n        fig.update_layout(title='Movement of the Point at the Bending Edge',\n                          xaxis_title='Position along the beam (mm)',\n                          yaxis_title='Displacement (mm) / Angle (degrees)',\n                          legend=dict(x=0.05, y=0.95),\n                          template='plotly_white')\n\n        if save_path:\n            # Save plot as an HTML file\n            fig.write_html(save_path)\n            print(f\"Plot saved to {save_path}\")\n        # Show the interactive plot\n        fig.show()\n</code></pre>"},{"location":"md/api/beam/#lib.BeamModel.VonKarmanBeamSolver.from_yaml","title":"<code>from_yaml(yaml_file)</code>  <code>classmethod</code>","text":"<p>Load parameters from a YAML file and initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_file</code> <code>str</code> <p>Path to the YAML file containing beam configuration parameters.</p> required <p>Returns:</p> Name Type Description <code>VonKarmanBeamSolver</code> <p>Instance of the VonKarmanBeamSolver class.</p> Source code in <code>lib/BeamModel.py</code> <pre><code>@classmethod\ndef from_yaml(cls, yaml_file):\n    \"\"\"\n    Load parameters from a YAML file and initialize the class.\n\n    Args:\n        yaml_file (str): Path to the YAML file containing beam configuration parameters.\n\n    Returns:\n        VonKarmanBeamSolver: Instance of the VonKarmanBeamSolver class.\n    \"\"\"\n    with open(yaml_file, 'r') as file:\n        data = yaml.safe_load(file)\n    return cls(\n        P=data['P'],\n        L=data['L'],\n        E=data['E'],\n        b=data['b'],\n        h=data['h'],\n        point_offset=data['point_offset'],\n        time_steps=data.get('time_steps', 100),\n        kappa=data.get('kappa', 5 / 6),\n        poisson_ratio=data.get('poisson_ratio', 0.33)\n    )\n</code></pre>"},{"location":"md/api/beam/#lib.BeamModel.VonKarmanBeamSolver.von_karman_beam","title":"<code>von_karman_beam(t, y, P)</code>","text":"<p>Differential equation for Von Karman beam bending.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Position along the beam.</p> required <code>y</code> <code>list of float</code> <p>State vector [deflection, slope, horizontal displacement].</p> required <code>P</code> <code>float</code> <p>Applied load at the current time step.</p> required <p>Returns:</p> Type Description <p>list of float: List of derivatives [dw/dx, d\u00b2w/dx\u00b2, du/dx].</p> Source code in <code>lib/BeamModel.py</code> <pre><code>def von_karman_beam(self, t, y, P):\n    \"\"\"\n    Differential equation for Von Karman beam bending.\n\n    Args:\n        t (float): Position along the beam.\n        y (list of float): State vector [deflection, slope, horizontal displacement].\n        P (float): Applied load at the current time step.\n\n    Returns:\n        list of float: List of derivatives [dw/dx, d\u00b2w/dx\u00b2, du/dx].\n    \"\"\"\n    w, dw_dx, u = y  # Deflection, slope, and horizontal displacement\n    d2w_dx2 = (P * (self.L - t)) / (self.E * self.I)  # Curvature\n    du_dx = 0.5 * (dw_dx ** 2)  # Horizontal stretch\n    return [dw_dx, d2w_dx2, du_dx]\n</code></pre>"},{"location":"md/api/beam/#lib.BeamModel.VonKarmanBeamSolver.solve","title":"<code>solve(save_path=None)</code>","text":"<p>Solve the beam equations using numerical integration.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>str</code> <p>Path to save the results as a CSV file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>lib/BeamModel.py</code> <pre><code>def solve(self, save_path=None):\n    \"\"\"\n    Solve the beam equations using numerical integration.\n\n    Args:\n        save_path (str, optional): Path to save the results as a CSV file. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    y0 = [0, 0, 0]  # Initial conditions: w(0) = 0, slope = 0, u(0) = 0\n    t_eval = np.linspace(0, self.L, 100)  # Evaluation points along the beam\n\n    # Store solutions for each time step where the force P increases linearly\n    self.solutions = []\n    self.applied_force = []\n\n    # Solve for t=0 with no force\n    sol_initial = solve_ivp(self.von_karman_beam, [0, self.L], y0, t_eval=t_eval, args=(0,))\n    self.solutions.append(sol_initial)\n\n    # Solve for subsequent timesteps where force increases linearly\n    for t_step in range(1, self.time_steps + 1):\n        P_current = self.P_max * (t_step / self.time_steps)  # Linearly increase force\n        self.applied_force.append(P_current)\n        sol = solve_ivp(self.von_karman_beam, [0, self.L], y0, t_eval=t_eval, args=(P_current,))\n        self.solutions.append(sol)\n\n        # Calculate yield and fatigue safety factors\n        yield_sf = self.calculate_safety_factor(P_current)\n        fatigue_sf = self.calculate_fatigue_safety_factor(P_current)\n        self.safety_factors_yield.append(yield_sf)\n        self.safety_factors_fatigue.append(fatigue_sf)\n\n        # Record the force when safety factors fall below 2\n        if yield_sf &lt; 2 and self.force_below_yield_sf is None:\n            self.force_below_yield_sf = P_current\n\n        if fatigue_sf &lt; 2 and self.force_below_fatigue_sf is None:\n            self.force_below_fatigue_sf = P_current\n\n    # Extract the final solution for plotting and saving\n    final_solution = self.solutions[-1]\n    self.x = final_solution.t  # Position along the beam\n    self.w = final_solution.y[0]  # Vertical deflection\n    self.u = final_solution.y[2]  # Horizontal displacement\n    self.slope = final_solution.y[1]  # Slope (dw/dx)\n    self.angle = np.degrees(self.slope)  # Slope in degrees\n\n    # Calculate total displacements\n    self.u_total = self.u + self.point_offset * np.sin(self.slope)\n    self.w_total = self.w + self.point_offset * (1 - np.cos(self.slope))\n\n    if save_path:\n        # Save data to a CSV file for the final time step\n        data = {\n            'Position (x)': self.x,\n            'Vertical Deflection (w)': self.w_total,\n            'Horizontal Displacement (u)': self.u_total,\n            'Angle of Slope (degrees)': self.angle,\n            'Safety Factor (Yield)': self.safety_factors_yield[-1],\n            'Safety Factor (Fatigue)': self.safety_factors_fatigue[-1]\n        }\n        df = pd.DataFrame(data)\n        df.to_csv(save_path, index=False)\n        print(f\"Data saved to {save_path}\")\n</code></pre>"},{"location":"md/api/beam/#lib.BeamModel.VonKarmanBeamSolver.calculate_safety_factor","title":"<code>calculate_safety_factor(P)</code>","text":"<p>Calculate the safety factor for yielding in bending.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>float</code> <p>Current applied load in Newtons.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Safety factor for bending.</p> Source code in <code>lib/BeamModel.py</code> <pre><code>def calculate_safety_factor(self, P):\n    \"\"\"\n    Calculate the safety factor for yielding in bending.\n\n    Args:\n        P (float): Current applied load in Newtons.\n\n    Returns:\n        float: Safety factor for bending.\n    \"\"\"\n    M_max = P * self.L / 4  # Maximum bending moment\n    c = self.h / 2  # Distance from neutral axis to outermost fiber\n    sigma_max = (M_max * c) / self.I  # Maximum stress in bending\n    safety_factor = self.yield_strength / sigma_max\n    return safety_factor\n</code></pre>"},{"location":"md/api/beam/#lib.BeamModel.VonKarmanBeamSolver.calculate_fatigue_safety_factor","title":"<code>calculate_fatigue_safety_factor(P)</code>","text":"<p>Calculate the safety factor for fatigue at 1e7 cycles.</p> <p>Parameters:</p> Name Type Description Default <code>P</code> <code>float</code> <p>Current applied load in Newtons.</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Safety factor for fatigue.</p> Source code in <code>lib/BeamModel.py</code> <pre><code>def calculate_fatigue_safety_factor(self, P):\n    \"\"\"\n    Calculate the safety factor for fatigue at 1e7 cycles.\n\n    Args:\n        P (float): Current applied load in Newtons.\n\n    Returns:\n        float: Safety factor for fatigue.\n    \"\"\"\n    M_max = P * self.L / 4  # Maximum bending moment\n    c = self.h / 2  # Distance from neutral axis to outermost fiber\n    sigma_max = (M_max * c) / self.I  # Maximum bending stress\n    safety_factor_fatigue = self.fatigue_strength / sigma_max\n    return safety_factor_fatigue\n</code></pre>"},{"location":"md/api/beam/#lib.BeamModel.VonKarmanBeamSolver.plot","title":"<code>plot(save_path=None)</code>","text":"<p>Generate an interactive plot using Plotly to visualize beam deflection and slope.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>str</code> <p>Path to save the plot as an HTML file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>lib/BeamModel.py</code> <pre><code>def plot(self, save_path=None):\n    \"\"\"\n    Generate an interactive plot using Plotly to visualize beam deflection and slope.\n\n    Args:\n        save_path (str, optional): Path to save the plot as an HTML file. Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    fig = go.Figure()\n\n    # Horizontal movement trace\n    fig.add_trace(go.Scatter(x=self.x, y=self.u_total, mode='lines', name='Horizontal Movement (u)',\n                             line=dict(color='blue')))\n\n    # Vertical movement trace\n    fig.add_trace(go.Scatter(x=self.x, y=self.w_total, mode='lines', name='Vertical Movement (w)',\n                             line=dict(color='red', dash='dash')))\n\n    # Angle trace\n    fig.add_trace(go.Scatter(x=self.x, y=self.angle, mode='lines', name='Angle of Slope (degrees)',\n                             line=dict(color='green', dash='dot')))\n\n    # Layout settings\n    fig.update_layout(title='Movement of the Point at the Bending Edge',\n                      xaxis_title='Position along the beam (mm)',\n                      yaxis_title='Displacement (mm) / Angle (degrees)',\n                      legend=dict(x=0.05, y=0.95),\n                      template='plotly_white')\n\n    if save_path:\n        # Save plot as an HTML file\n        fig.write_html(save_path)\n        print(f\"Plot saved to {save_path}\")\n    # Show the interactive plot\n    fig.show()\n</code></pre>"},{"location":"md/api/mag/","title":"Magnetic Field Simulation","text":"<p>Class to simulate the interaction between magnets and sensors using Magpylib.</p> Source code in <code>lib/MagSim.py</code> <pre><code>class MagnetSensorSimulation:\n    \"\"\"\n    Class to simulate the interaction between magnets and sensors using Magpylib.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the MagnetSensorSimulation class.\n\n        Attributes:\n            sensors (list): List of sensors in the simulation.\n            magnets (list): List of magnets in the simulation.\n        \"\"\"\n        self.sensors = []\n        self.magnets = []\n\n    def add_sensor(self, sensor_pixels, sensor_position, sensor_orientation=None, style_label=\"Sensor\", stl_file=None, stl_offset=None):\n        \"\"\"\n        Adds a sensor to the simulation, with an optional STL file for 3D model representation.\n\n        Args:\n            sensor_pixels (list): List of pixel coordinates for the sensor.\n            sensor_position (list): 3D position of the sensor [x, y, z].\n            sensor_orientation (scipy.spatial.transform.Rotation, optional): Orientation of the sensor as Euler angles.\n                Defaults to no rotation.\n            style_label (str, optional): Label for the sensor. Defaults to \"Sensor\".\n            stl_file (str, optional): Path to the STL file representing the sensor. Defaults to None.\n            stl_offset (list, optional): Offset to apply to the STL model. Defaults to None.\n        \"\"\"\n        sensor_orientation = sensor_orientation or R.from_euler('xyz', [0, 0, 0])\n        sensor = magpy.Sensor(\n            pixel=sensor_pixels,\n            position=sensor_position,\n            orientation=sensor_orientation,\n            style_label=style_label\n        )\n\n        if stl_file:\n            trace = self.trace_from_stl(stl_file, stl_offset)\n            sensor.style.model3d.add_trace(trace)\n\n        self.sensors.append(sensor)\n\n    def add_magnet(self, shape, polarization, dimension, position, orientation=None, style_magnetization=None):\n        \"\"\"\n        Adds a magnet of a specific shape to the simulation.\n\n        Args:\n            shape (str): Shape of the magnet (\"cylinder\", \"cube\", \"sphere\", or \"cylinder_segment\").\n            polarization (tuple): Polarization vector of the magnet.\n            dimension (tuple or float): Dimensions of the magnet (e.g., diameter, length).\n            position (list): 3D position of the magnet [x, y, z].\n            orientation (scipy.spatial.transform.Rotation, optional): Orientation of the magnet. Defaults to no rotation.\n            style_magnetization (dict, optional): Style parameters for the magnet visualization. Defaults to None.\n        \"\"\"\n        if shape == \"cylinder\":\n            magnet = magpy.magnet.Cylinder(\n                polarization=polarization,\n                dimension=dimension,\n                position=position,\n                orientation=orientation or R.from_euler('xyz', [0, 0, 0]),\n                style_magnetization=style_magnetization,\n                style_label=f\"magnet_{len(self.magnets) + 1}\",\n            )\n        elif shape == \"cube\":\n            magnet = magpy.magnet.Cuboid(\n                polarization=polarization,\n                dimension=dimension,\n                position=position,\n                orientation=orientation or R.from_euler('xyz', [0, 0, 0]),\n                style_magnetization=style_magnetization,\n                style_label=f\"magnet_{len(self.magnets) + 1}\",\n            )\n        elif shape == 'sphere':\n            magnet = magpy.magnet.Sphere(\n                polarization=polarization,\n                diameter=dimension,\n                position=position,\n                orientation=orientation or R.from_euler('xyz', [0, 0, 0]),\n                style_magnetization=style_magnetization,\n                style_label=f\"magnet_{len(self.magnets) + 1}\",\n            )\n        elif shape == 'cylinder_segment':\n            magnet = magpy.magnet.CylinderSegment(\n                polarization=polarization,\n                dimension=dimension,\n                position=position,\n                orientation=orientation or R.from_euler('xyz', [0, 0, 0]),\n                style_magnetization=style_magnetization,\n                style_label=f\"magnet_{len(self.magnets) + 1}\",\n            )\n        else:\n            raise ValueError(f\"Unsupported magnet shape: {shape}\")\n\n        self.magnets.append(magnet)\n\n    def set_magnet_path(self, path_positions, path_orientations, magnet_index=0):\n        \"\"\"\n        Set the movement and rotation path for a specific magnet in the simulation.\n\n        Args:\n            path_positions (list): List of positions for the magnet path.\n            path_orientations (list): List of orientations for the magnet path.\n            magnet_index (int, optional): Index of the magnet to apply the path to. Defaults to 0.\n\n        Raises:\n            IndexError: If the magnet_index is out of range.\n        \"\"\"\n        if magnet_index &gt;= len(self.magnets):\n            raise IndexError(f\"Magnet index {magnet_index} out of range.\")\n\n        magnet = self.magnets[magnet_index]\n        magnet.move(path_positions, start=0)\n        magnet.rotate_from_euler(path_orientations, seq='xyz', start=0)\n\n    def set_sensor_path(self, path_positions, path_orientations, sensor_index=0):\n        \"\"\"\n        Set the movement and rotation path for a specific sensor in the simulation.\n\n        Args:\n            path_positions (list): List of positions for the sensor path.\n            path_orientations (list): List of orientations for the sensor path.\n            sensor_index (int, optional): Index of the sensor to apply the path to. Defaults to 0.\n\n        Raises:\n            IndexError: If the sensor_index is out of range.\n        \"\"\"\n        if sensor_index &gt;= len(self.sensors):\n            raise IndexError(f\"Sensor index {sensor_index} out of range.\")\n\n        sensor = self.sensors[sensor_index]\n        sensor.move(path_positions, start=0)\n        sensor.rotate_from_euler(path_orientations, seq='xyz', start=0)\n\n    def get_magnetic_field_at_sensors(self, sensor_index=0):\n        \"\"\"\n        Compute the magnetic field at the position of a specific sensor for each timestep.\n\n        Args:\n            sensor_index (int, optional): Index of the sensor. Defaults to 0.\n\n        Returns:\n            np.ndarray: Magnetic field components (Bx, By, Bz) at each timestep.\n\n        Raises:\n            IndexError: If the sensor_index is out of range.\n        \"\"\"\n        if sensor_index &gt;= len(self.sensors):\n            raise IndexError(f\"Sensor index {sensor_index} out of range.\")\n\n        sensor = self.sensors[sensor_index]\n        B_field = magpy.getB(self.magnets, sensor)\n        return B_field\n\n    def display_simulation(self, animation=True, backend=\"plotly\"):\n        \"\"\"\n        Display the magnet and sensor simulation with optional animation.\n\n        Args:\n            animation (bool, optional): Whether to animate the simulation. Defaults to True.\n            backend (str, optional): The backend for rendering the simulation. Defaults to \"plotly\".\n        \"\"\"\n        fig = magpy.show(*self.sensors, *self.magnets, animation=animation, backend=backend, return_fig=True)\n\n        fig.update_layout(\n            scene=dict(\n                xaxis=dict(backgroundcolor=\"white\"),\n                yaxis=dict(backgroundcolor=\"white\"),\n                zaxis=dict(backgroundcolor=\"white\"),\n            ),\n            paper_bgcolor=\"white\",\n            plot_bgcolor=\"white\"\n        )\n        fig.show()\n\n    @staticmethod\n    def _bin_color_to_hex(x):\n        \"\"\"\n        Converts binary RGB value to hexadecimal color.\n\n        Args:\n            x (int): Binary RGB value.\n\n        Returns:\n            str: Hexadecimal color code.\n        \"\"\"\n        sb = f\"{x:015b}\"[::-1]\n        r = int(sb[:5], base=2) / 31\n        g = int(sb[5:10], base=2) / 31\n        b = int(sb[10:15], base=2) / 31\n        return to_hex((r, g, b))\n\n    def trace_from_stl(self, stl_file, stl_offset=None):\n        \"\"\"\n        Generate a Magpylib 3D model trace from an STL file, applying an optional offset.\n\n        Args:\n            stl_file (str): Path to the STL file.\n            stl_offset (list, optional): 3D offset to apply to the STL vertices. Defaults to None.\n\n        Returns:\n            dict: Trace dictionary for rendering the STL model in Magpylib.\n        \"\"\"\n        stl_mesh = Mesh.from_file(stl_file)\n        vertices, ixr = np.unique(stl_mesh.vectors.reshape(-1, 3), return_inverse=True, axis=0)\n\n        if stl_offset is not None:\n            vertices += np.array(stl_offset) * 1e3  # Apply offset in mm\n\n        i = np.take(ixr, range(0, len(ixr), 3))\n        j = np.take(ixr, range(1, len(ixr), 3))\n        k = np.take(ixr, range(2, len(ixr), 3))\n        x, y, z = vertices.T / 1000  # Convert from mm to meters\n\n        colors = stl_mesh.attr.flatten()\n        facecolor = np.array([self._bin_color_to_hex(c) for c in colors]).T\n\n        return {\"backend\": \"generic\", \"constructor\": \"mesh3d\",\n                \"kwargs\": dict(x=x, y=y, z=z, i=i, j=j, k=k, facecolor=facecolor)}\n\n    def display_with_outputs(self, backend='plotly', animation=True, show=True):\n        \"\"\"\n        Display the magnetic field components (Bx, By, Bz) and the 3D model in a multi-column layout.\n\n        Args:\n            backend (str, optional): The backend for rendering the simulation. Defaults to \"plotly\".\n            animation (bool, optional): Whether to animate the simulation. Defaults to True.\n            show (bool, optional): Whether to display the plot immediately. Defaults to True.\n\n        Returns:\n            plotly.graph_objects.Figure: The generated figure.\n        \"\"\"\n        if not self.sensors:\n            raise ValueError(\"No sensors added to the simulation.\")\n        fig = magpy.show(\n            dict(objects=[*self.magnets, *self.sensors], output=[\"Bx\", \"By\", \"Bz\"], col=1),\n            dict(objects=[*self.magnets, *self.sensors], output=\"model3d\", col=2),\n            backend=backend, animation=animation, return_fig=True,\n        )\n\n        fig.update_layout(\n            scene=dict(\n                xaxis=dict(\n                    backgroundcolor=\"white\",\n                    color=\"black\",\n                    gridcolor=\"lightgray\",\n                    range=[-0.005, 0.005],\n                ),\n                yaxis=dict(\n                    backgroundcolor=\"white\",\n                    color=\"black\",\n                    gridcolor=\"lightgray\",\n        range = [-0.005, 0.005],\n        ),\n                zaxis=dict(\n                    backgroundcolor=\"white\",\n                    color=\"black\",\n                    gridcolor=\"lightgray\",\n                    range=[-0.001, 0.009],\n\n                ),\n                aspectmode='cube',\n            ),\n            paper_bgcolor=\"white\",\n            plot_bgcolor=\"white\"\n        )\n\n        if show:\n            fig.show()\n        return fig\n\n\n    def stream_plot(self, plane=\"XY\", plane_limits=(-0.05, 0.05), resolution=100, timestep=0, save_path=None, show=True):\n        \"\"\"\n        Generate and optionally save a magnetic field stream plot for a specified plane at a specific timestep.\n\n        Args:\n            plane (str, optional): Plane to generate the plot ('XY', 'XZ', or 'YZ'). Defaults to 'XY'.\n            plane_limits (tuple, optional): Range of the plane axes. Defaults to (-0.05, 0.05).\n            resolution (int, optional): Grid resolution for the plot. Defaults to 100.\n            timestep (int, optional): Timestep to plot. Set to -1 for the last timestep. Defaults to 0.\n            save_path (str, optional): Path to save the plot. Defaults to None.\n            show (bool, optional): Whether to display the plot. Defaults to True.\n\n        Raises:\n            ValueError: If the timestep or plane is out of range.\n        \"\"\"\n        fig, ax = plt.subplots()\n        num_timesteps = len(self.magnets[0].position)\n\n        if timestep == -1:\n            timestep = num_timesteps - 1\n\n        if timestep &lt; 0 or timestep &gt;= num_timesteps:\n            raise ValueError(f\"Timestep {timestep} is out of range (0 to {num_timesteps - 1}).\")\n\n        for magnet in self.magnets:\n            if isinstance(magnet.position[0], (list, tuple, np.ndarray)):\n                magnet.position = magnet.position[timestep]\n            if isinstance(magnet.orientation, list) or isinstance(magnet.orientation, np.ndarray):\n                magnet.orientation = magnet.orientation[timestep]\n\n        if plane == \"XY\":\n            X, Y = np.meshgrid(\n                np.linspace(plane_limits[0], plane_limits[1], resolution),\n                np.linspace(plane_limits[0], plane_limits[1], resolution)\n            )\n            Z = np.zeros_like(X)\n            grid = np.stack([X, Y, Z], axis=-1)\n        elif plane == \"XZ\":\n            X, Z = np.meshgrid(\n                np.linspace(plane_limits[0], plane_limits[1], resolution),\n                np.linspace(plane_limits[0], plane_limits[1], resolution)\n            )\n            Y = np.zeros_like(X)\n            grid = np.stack([X, Y, Z], axis=-1)\n        elif plane == \"YZ\":\n            Y, Z = np.meshgrid(\n                np.linspace(plane_limits[0], plane_limits[1], resolution),\n                np.linspace(plane_limits[0], plane_limits[1], resolution)\n            )\n            X = np.zeros_like(Y)\n            grid = np.stack([X, Y, Z], axis=-1)\n        else:\n            raise ValueError(f\"Unsupported plane: {plane}. Choose from 'XY', 'XZ', or 'YZ'.\")\n\n        B = magpy.getB(self.magnets, observers=grid.reshape(-1, 3)).reshape(grid.shape)\n\n        if plane == \"XY\":\n            Bx, By = B[:, :, 0], B[:, :, 1]\n            normB = np.linalg.norm(B[:, :, :2], axis=-1)\n            cp = ax.contourf(X, Y, normB, cmap=\"GnBu\", levels=100)\n            ax.streamplot(X, Y, Bx, By, color=\"k\", density=1.5, linewidth=1)\n        elif plane == \"XZ\":\n            Bx, Bz = B[:, :, 0], B[:, :, 2]\n            normB = np.linalg.norm(B[:, :, [0, 2]], axis=-1)\n            cp = ax.contourf(X, Z, normB, cmap=\"GnBu\", levels=100)\n            ax.streamplot(X, Z, Bx, Bz, color=\"k\", density=1.5, linewidth=1)\n        elif plane == \"YZ\":\n            By, Bz = B[:, :, 1], B[:, :, 2]\n            normB = np.linalg.norm(B[:, :, [1, 2]], axis=-1)\n            cp = ax.contourf(Y, Z, normB, cmap=\"GnBu\", levels=100)\n            ax.streamplot(Y, Z, By, Bz, color=\"k\", density=1.5, linewidth=1)\n\n        fig.colorbar(cp, ax=ax, label=\"|B| (T)\")\n        ax.set_xlabel(f'{plane[0]}-position (m)')\n        ax.set_ylabel(f'{plane[1]}-position (m)')\n        ax.set_aspect('equal')\n\n        plt.tight_layout()\n\n        if save_path:\n            output_dir = os.path.dirname(save_path)\n            if output_dir and not os.path.exists(output_dir):\n                os.makedirs(output_dir)\n            fig.savefig(save_path)\n            print(f\"Stream plot saved to {save_path}\")\n        if show:\n            plt.show()\n\n        plt.close(fig)\n\n    def save_b_field(self, filepath, sensor_index=0):\n        \"\"\"\n        Save the magnetic field (B_field) data to a CSV file with x path positions in the first column.\n\n        Args:\n            filepath (str): Path to save the CSV file.\n            sensor_index (int, optional): Index of the sensor to get magnetic field data for. Defaults to 0.\n\n        Raises:\n            IndexError: If the sensor_index is out of range.\n        \"\"\"\n        if sensor_index &gt;= len(self.sensors):\n            raise IndexError(f\"Sensor index {sensor_index} out of range.\")\n\n        B_field = self.get_magnetic_field_at_sensors(sensor_index)\n        x_positions = [pos[0] for pos in self.magnets[0].position]\n\n        data = {\n            \"x_position\": x_positions,\n            \"Bx\": B_field[:, 0],  # Magnetic field component in the x-direction\n            \"By\": B_field[:, 1],  # Magnetic field component in the y-direction\n            \"Bz\": B_field[:, 2],  # Magnetic field component in the z-direction\n        }\n\n        df = pd.DataFrame(data)\n        df.to_csv(filepath, index=False)\n        print(f\"B_field data saved to {filepath}\")\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.add_sensor","title":"<code>add_sensor(sensor_pixels, sensor_position, sensor_orientation=None, style_label='Sensor', stl_file=None, stl_offset=None)</code>","text":"<p>Adds a sensor to the simulation, with an optional STL file for 3D model representation.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_pixels</code> <code>list</code> <p>List of pixel coordinates for the sensor.</p> required <code>sensor_position</code> <code>list</code> <p>3D position of the sensor [x, y, z].</p> required <code>sensor_orientation</code> <code>Rotation</code> <p>Orientation of the sensor as Euler angles. Defaults to no rotation.</p> <code>None</code> <code>style_label</code> <code>str</code> <p>Label for the sensor. Defaults to \"Sensor\".</p> <code>'Sensor'</code> <code>stl_file</code> <code>str</code> <p>Path to the STL file representing the sensor. Defaults to None.</p> <code>None</code> <code>stl_offset</code> <code>list</code> <p>Offset to apply to the STL model. Defaults to None.</p> <code>None</code> Source code in <code>lib/MagSim.py</code> <pre><code>def add_sensor(self, sensor_pixels, sensor_position, sensor_orientation=None, style_label=\"Sensor\", stl_file=None, stl_offset=None):\n    \"\"\"\n    Adds a sensor to the simulation, with an optional STL file for 3D model representation.\n\n    Args:\n        sensor_pixels (list): List of pixel coordinates for the sensor.\n        sensor_position (list): 3D position of the sensor [x, y, z].\n        sensor_orientation (scipy.spatial.transform.Rotation, optional): Orientation of the sensor as Euler angles.\n            Defaults to no rotation.\n        style_label (str, optional): Label for the sensor. Defaults to \"Sensor\".\n        stl_file (str, optional): Path to the STL file representing the sensor. Defaults to None.\n        stl_offset (list, optional): Offset to apply to the STL model. Defaults to None.\n    \"\"\"\n    sensor_orientation = sensor_orientation or R.from_euler('xyz', [0, 0, 0])\n    sensor = magpy.Sensor(\n        pixel=sensor_pixels,\n        position=sensor_position,\n        orientation=sensor_orientation,\n        style_label=style_label\n    )\n\n    if stl_file:\n        trace = self.trace_from_stl(stl_file, stl_offset)\n        sensor.style.model3d.add_trace(trace)\n\n    self.sensors.append(sensor)\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.add_magnet","title":"<code>add_magnet(shape, polarization, dimension, position, orientation=None, style_magnetization=None)</code>","text":"<p>Adds a magnet of a specific shape to the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>str</code> <p>Shape of the magnet (\"cylinder\", \"cube\", \"sphere\", or \"cylinder_segment\").</p> required <code>polarization</code> <code>tuple</code> <p>Polarization vector of the magnet.</p> required <code>dimension</code> <code>tuple or float</code> <p>Dimensions of the magnet (e.g., diameter, length).</p> required <code>position</code> <code>list</code> <p>3D position of the magnet [x, y, z].</p> required <code>orientation</code> <code>Rotation</code> <p>Orientation of the magnet. Defaults to no rotation.</p> <code>None</code> <code>style_magnetization</code> <code>dict</code> <p>Style parameters for the magnet visualization. Defaults to None.</p> <code>None</code> Source code in <code>lib/MagSim.py</code> <pre><code>def add_magnet(self, shape, polarization, dimension, position, orientation=None, style_magnetization=None):\n    \"\"\"\n    Adds a magnet of a specific shape to the simulation.\n\n    Args:\n        shape (str): Shape of the magnet (\"cylinder\", \"cube\", \"sphere\", or \"cylinder_segment\").\n        polarization (tuple): Polarization vector of the magnet.\n        dimension (tuple or float): Dimensions of the magnet (e.g., diameter, length).\n        position (list): 3D position of the magnet [x, y, z].\n        orientation (scipy.spatial.transform.Rotation, optional): Orientation of the magnet. Defaults to no rotation.\n        style_magnetization (dict, optional): Style parameters for the magnet visualization. Defaults to None.\n    \"\"\"\n    if shape == \"cylinder\":\n        magnet = magpy.magnet.Cylinder(\n            polarization=polarization,\n            dimension=dimension,\n            position=position,\n            orientation=orientation or R.from_euler('xyz', [0, 0, 0]),\n            style_magnetization=style_magnetization,\n            style_label=f\"magnet_{len(self.magnets) + 1}\",\n        )\n    elif shape == \"cube\":\n        magnet = magpy.magnet.Cuboid(\n            polarization=polarization,\n            dimension=dimension,\n            position=position,\n            orientation=orientation or R.from_euler('xyz', [0, 0, 0]),\n            style_magnetization=style_magnetization,\n            style_label=f\"magnet_{len(self.magnets) + 1}\",\n        )\n    elif shape == 'sphere':\n        magnet = magpy.magnet.Sphere(\n            polarization=polarization,\n            diameter=dimension,\n            position=position,\n            orientation=orientation or R.from_euler('xyz', [0, 0, 0]),\n            style_magnetization=style_magnetization,\n            style_label=f\"magnet_{len(self.magnets) + 1}\",\n        )\n    elif shape == 'cylinder_segment':\n        magnet = magpy.magnet.CylinderSegment(\n            polarization=polarization,\n            dimension=dimension,\n            position=position,\n            orientation=orientation or R.from_euler('xyz', [0, 0, 0]),\n            style_magnetization=style_magnetization,\n            style_label=f\"magnet_{len(self.magnets) + 1}\",\n        )\n    else:\n        raise ValueError(f\"Unsupported magnet shape: {shape}\")\n\n    self.magnets.append(magnet)\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.set_magnet_path","title":"<code>set_magnet_path(path_positions, path_orientations, magnet_index=0)</code>","text":"<p>Set the movement and rotation path for a specific magnet in the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>path_positions</code> <code>list</code> <p>List of positions for the magnet path.</p> required <code>path_orientations</code> <code>list</code> <p>List of orientations for the magnet path.</p> required <code>magnet_index</code> <code>int</code> <p>Index of the magnet to apply the path to. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the magnet_index is out of range.</p> Source code in <code>lib/MagSim.py</code> <pre><code>def set_magnet_path(self, path_positions, path_orientations, magnet_index=0):\n    \"\"\"\n    Set the movement and rotation path for a specific magnet in the simulation.\n\n    Args:\n        path_positions (list): List of positions for the magnet path.\n        path_orientations (list): List of orientations for the magnet path.\n        magnet_index (int, optional): Index of the magnet to apply the path to. Defaults to 0.\n\n    Raises:\n        IndexError: If the magnet_index is out of range.\n    \"\"\"\n    if magnet_index &gt;= len(self.magnets):\n        raise IndexError(f\"Magnet index {magnet_index} out of range.\")\n\n    magnet = self.magnets[magnet_index]\n    magnet.move(path_positions, start=0)\n    magnet.rotate_from_euler(path_orientations, seq='xyz', start=0)\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.set_sensor_path","title":"<code>set_sensor_path(path_positions, path_orientations, sensor_index=0)</code>","text":"<p>Set the movement and rotation path for a specific sensor in the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>path_positions</code> <code>list</code> <p>List of positions for the sensor path.</p> required <code>path_orientations</code> <code>list</code> <p>List of orientations for the sensor path.</p> required <code>sensor_index</code> <code>int</code> <p>Index of the sensor to apply the path to. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sensor_index is out of range.</p> Source code in <code>lib/MagSim.py</code> <pre><code>def set_sensor_path(self, path_positions, path_orientations, sensor_index=0):\n    \"\"\"\n    Set the movement and rotation path for a specific sensor in the simulation.\n\n    Args:\n        path_positions (list): List of positions for the sensor path.\n        path_orientations (list): List of orientations for the sensor path.\n        sensor_index (int, optional): Index of the sensor to apply the path to. Defaults to 0.\n\n    Raises:\n        IndexError: If the sensor_index is out of range.\n    \"\"\"\n    if sensor_index &gt;= len(self.sensors):\n        raise IndexError(f\"Sensor index {sensor_index} out of range.\")\n\n    sensor = self.sensors[sensor_index]\n    sensor.move(path_positions, start=0)\n    sensor.rotate_from_euler(path_orientations, seq='xyz', start=0)\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.get_magnetic_field_at_sensors","title":"<code>get_magnetic_field_at_sensors(sensor_index=0)</code>","text":"<p>Compute the magnetic field at the position of a specific sensor for each timestep.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_index</code> <code>int</code> <p>Index of the sensor. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <p>np.ndarray: Magnetic field components (Bx, By, Bz) at each timestep.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sensor_index is out of range.</p> Source code in <code>lib/MagSim.py</code> <pre><code>def get_magnetic_field_at_sensors(self, sensor_index=0):\n    \"\"\"\n    Compute the magnetic field at the position of a specific sensor for each timestep.\n\n    Args:\n        sensor_index (int, optional): Index of the sensor. Defaults to 0.\n\n    Returns:\n        np.ndarray: Magnetic field components (Bx, By, Bz) at each timestep.\n\n    Raises:\n        IndexError: If the sensor_index is out of range.\n    \"\"\"\n    if sensor_index &gt;= len(self.sensors):\n        raise IndexError(f\"Sensor index {sensor_index} out of range.\")\n\n    sensor = self.sensors[sensor_index]\n    B_field = magpy.getB(self.magnets, sensor)\n    return B_field\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.display_simulation","title":"<code>display_simulation(animation=True, backend='plotly')</code>","text":"<p>Display the magnet and sensor simulation with optional animation.</p> <p>Parameters:</p> Name Type Description Default <code>animation</code> <code>bool</code> <p>Whether to animate the simulation. Defaults to True.</p> <code>True</code> <code>backend</code> <code>str</code> <p>The backend for rendering the simulation. Defaults to \"plotly\".</p> <code>'plotly'</code> Source code in <code>lib/MagSim.py</code> <pre><code>def display_simulation(self, animation=True, backend=\"plotly\"):\n    \"\"\"\n    Display the magnet and sensor simulation with optional animation.\n\n    Args:\n        animation (bool, optional): Whether to animate the simulation. Defaults to True.\n        backend (str, optional): The backend for rendering the simulation. Defaults to \"plotly\".\n    \"\"\"\n    fig = magpy.show(*self.sensors, *self.magnets, animation=animation, backend=backend, return_fig=True)\n\n    fig.update_layout(\n        scene=dict(\n            xaxis=dict(backgroundcolor=\"white\"),\n            yaxis=dict(backgroundcolor=\"white\"),\n            zaxis=dict(backgroundcolor=\"white\"),\n        ),\n        paper_bgcolor=\"white\",\n        plot_bgcolor=\"white\"\n    )\n    fig.show()\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation._bin_color_to_hex","title":"<code>_bin_color_to_hex(x)</code>  <code>staticmethod</code>","text":"<p>Converts binary RGB value to hexadecimal color.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Binary RGB value.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Hexadecimal color code.</p> Source code in <code>lib/MagSim.py</code> <pre><code>@staticmethod\ndef _bin_color_to_hex(x):\n    \"\"\"\n    Converts binary RGB value to hexadecimal color.\n\n    Args:\n        x (int): Binary RGB value.\n\n    Returns:\n        str: Hexadecimal color code.\n    \"\"\"\n    sb = f\"{x:015b}\"[::-1]\n    r = int(sb[:5], base=2) / 31\n    g = int(sb[5:10], base=2) / 31\n    b = int(sb[10:15], base=2) / 31\n    return to_hex((r, g, b))\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.trace_from_stl","title":"<code>trace_from_stl(stl_file, stl_offset=None)</code>","text":"<p>Generate a Magpylib 3D model trace from an STL file, applying an optional offset.</p> <p>Parameters:</p> Name Type Description Default <code>stl_file</code> <code>str</code> <p>Path to the STL file.</p> required <code>stl_offset</code> <code>list</code> <p>3D offset to apply to the STL vertices. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Trace dictionary for rendering the STL model in Magpylib.</p> Source code in <code>lib/MagSim.py</code> <pre><code>def trace_from_stl(self, stl_file, stl_offset=None):\n    \"\"\"\n    Generate a Magpylib 3D model trace from an STL file, applying an optional offset.\n\n    Args:\n        stl_file (str): Path to the STL file.\n        stl_offset (list, optional): 3D offset to apply to the STL vertices. Defaults to None.\n\n    Returns:\n        dict: Trace dictionary for rendering the STL model in Magpylib.\n    \"\"\"\n    stl_mesh = Mesh.from_file(stl_file)\n    vertices, ixr = np.unique(stl_mesh.vectors.reshape(-1, 3), return_inverse=True, axis=0)\n\n    if stl_offset is not None:\n        vertices += np.array(stl_offset) * 1e3  # Apply offset in mm\n\n    i = np.take(ixr, range(0, len(ixr), 3))\n    j = np.take(ixr, range(1, len(ixr), 3))\n    k = np.take(ixr, range(2, len(ixr), 3))\n    x, y, z = vertices.T / 1000  # Convert from mm to meters\n\n    colors = stl_mesh.attr.flatten()\n    facecolor = np.array([self._bin_color_to_hex(c) for c in colors]).T\n\n    return {\"backend\": \"generic\", \"constructor\": \"mesh3d\",\n            \"kwargs\": dict(x=x, y=y, z=z, i=i, j=j, k=k, facecolor=facecolor)}\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.display_with_outputs","title":"<code>display_with_outputs(backend='plotly', animation=True, show=True)</code>","text":"<p>Display the magnetic field components (Bx, By, Bz) and the 3D model in a multi-column layout.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>The backend for rendering the simulation. Defaults to \"plotly\".</p> <code>'plotly'</code> <code>animation</code> <code>bool</code> <p>Whether to animate the simulation. Defaults to True.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to display the plot immediately. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>plotly.graph_objects.Figure: The generated figure.</p> Source code in <code>lib/MagSim.py</code> <pre><code>def display_with_outputs(self, backend='plotly', animation=True, show=True):\n    \"\"\"\n    Display the magnetic field components (Bx, By, Bz) and the 3D model in a multi-column layout.\n\n    Args:\n        backend (str, optional): The backend for rendering the simulation. Defaults to \"plotly\".\n        animation (bool, optional): Whether to animate the simulation. Defaults to True.\n        show (bool, optional): Whether to display the plot immediately. Defaults to True.\n\n    Returns:\n        plotly.graph_objects.Figure: The generated figure.\n    \"\"\"\n    if not self.sensors:\n        raise ValueError(\"No sensors added to the simulation.\")\n    fig = magpy.show(\n        dict(objects=[*self.magnets, *self.sensors], output=[\"Bx\", \"By\", \"Bz\"], col=1),\n        dict(objects=[*self.magnets, *self.sensors], output=\"model3d\", col=2),\n        backend=backend, animation=animation, return_fig=True,\n    )\n\n    fig.update_layout(\n        scene=dict(\n            xaxis=dict(\n                backgroundcolor=\"white\",\n                color=\"black\",\n                gridcolor=\"lightgray\",\n                range=[-0.005, 0.005],\n            ),\n            yaxis=dict(\n                backgroundcolor=\"white\",\n                color=\"black\",\n                gridcolor=\"lightgray\",\n    range = [-0.005, 0.005],\n    ),\n            zaxis=dict(\n                backgroundcolor=\"white\",\n                color=\"black\",\n                gridcolor=\"lightgray\",\n                range=[-0.001, 0.009],\n\n            ),\n            aspectmode='cube',\n        ),\n        paper_bgcolor=\"white\",\n        plot_bgcolor=\"white\"\n    )\n\n    if show:\n        fig.show()\n    return fig\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.stream_plot","title":"<code>stream_plot(plane='XY', plane_limits=(-0.05, 0.05), resolution=100, timestep=0, save_path=None, show=True)</code>","text":"<p>Generate and optionally save a magnetic field stream plot for a specified plane at a specific timestep.</p> <p>Parameters:</p> Name Type Description Default <code>plane</code> <code>str</code> <p>Plane to generate the plot ('XY', 'XZ', or 'YZ'). Defaults to 'XY'.</p> <code>'XY'</code> <code>plane_limits</code> <code>tuple</code> <p>Range of the plane axes. Defaults to (-0.05, 0.05).</p> <code>(-0.05, 0.05)</code> <code>resolution</code> <code>int</code> <p>Grid resolution for the plot. Defaults to 100.</p> <code>100</code> <code>timestep</code> <code>int</code> <p>Timestep to plot. Set to -1 for the last timestep. Defaults to 0.</p> <code>0</code> <code>save_path</code> <code>str</code> <p>Path to save the plot. Defaults to None.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the timestep or plane is out of range.</p> Source code in <code>lib/MagSim.py</code> <pre><code>def stream_plot(self, plane=\"XY\", plane_limits=(-0.05, 0.05), resolution=100, timestep=0, save_path=None, show=True):\n    \"\"\"\n    Generate and optionally save a magnetic field stream plot for a specified plane at a specific timestep.\n\n    Args:\n        plane (str, optional): Plane to generate the plot ('XY', 'XZ', or 'YZ'). Defaults to 'XY'.\n        plane_limits (tuple, optional): Range of the plane axes. Defaults to (-0.05, 0.05).\n        resolution (int, optional): Grid resolution for the plot. Defaults to 100.\n        timestep (int, optional): Timestep to plot. Set to -1 for the last timestep. Defaults to 0.\n        save_path (str, optional): Path to save the plot. Defaults to None.\n        show (bool, optional): Whether to display the plot. Defaults to True.\n\n    Raises:\n        ValueError: If the timestep or plane is out of range.\n    \"\"\"\n    fig, ax = plt.subplots()\n    num_timesteps = len(self.magnets[0].position)\n\n    if timestep == -1:\n        timestep = num_timesteps - 1\n\n    if timestep &lt; 0 or timestep &gt;= num_timesteps:\n        raise ValueError(f\"Timestep {timestep} is out of range (0 to {num_timesteps - 1}).\")\n\n    for magnet in self.magnets:\n        if isinstance(magnet.position[0], (list, tuple, np.ndarray)):\n            magnet.position = magnet.position[timestep]\n        if isinstance(magnet.orientation, list) or isinstance(magnet.orientation, np.ndarray):\n            magnet.orientation = magnet.orientation[timestep]\n\n    if plane == \"XY\":\n        X, Y = np.meshgrid(\n            np.linspace(plane_limits[0], plane_limits[1], resolution),\n            np.linspace(plane_limits[0], plane_limits[1], resolution)\n        )\n        Z = np.zeros_like(X)\n        grid = np.stack([X, Y, Z], axis=-1)\n    elif plane == \"XZ\":\n        X, Z = np.meshgrid(\n            np.linspace(plane_limits[0], plane_limits[1], resolution),\n            np.linspace(plane_limits[0], plane_limits[1], resolution)\n        )\n        Y = np.zeros_like(X)\n        grid = np.stack([X, Y, Z], axis=-1)\n    elif plane == \"YZ\":\n        Y, Z = np.meshgrid(\n            np.linspace(plane_limits[0], plane_limits[1], resolution),\n            np.linspace(plane_limits[0], plane_limits[1], resolution)\n        )\n        X = np.zeros_like(Y)\n        grid = np.stack([X, Y, Z], axis=-1)\n    else:\n        raise ValueError(f\"Unsupported plane: {plane}. Choose from 'XY', 'XZ', or 'YZ'.\")\n\n    B = magpy.getB(self.magnets, observers=grid.reshape(-1, 3)).reshape(grid.shape)\n\n    if plane == \"XY\":\n        Bx, By = B[:, :, 0], B[:, :, 1]\n        normB = np.linalg.norm(B[:, :, :2], axis=-1)\n        cp = ax.contourf(X, Y, normB, cmap=\"GnBu\", levels=100)\n        ax.streamplot(X, Y, Bx, By, color=\"k\", density=1.5, linewidth=1)\n    elif plane == \"XZ\":\n        Bx, Bz = B[:, :, 0], B[:, :, 2]\n        normB = np.linalg.norm(B[:, :, [0, 2]], axis=-1)\n        cp = ax.contourf(X, Z, normB, cmap=\"GnBu\", levels=100)\n        ax.streamplot(X, Z, Bx, Bz, color=\"k\", density=1.5, linewidth=1)\n    elif plane == \"YZ\":\n        By, Bz = B[:, :, 1], B[:, :, 2]\n        normB = np.linalg.norm(B[:, :, [1, 2]], axis=-1)\n        cp = ax.contourf(Y, Z, normB, cmap=\"GnBu\", levels=100)\n        ax.streamplot(Y, Z, By, Bz, color=\"k\", density=1.5, linewidth=1)\n\n    fig.colorbar(cp, ax=ax, label=\"|B| (T)\")\n    ax.set_xlabel(f'{plane[0]}-position (m)')\n    ax.set_ylabel(f'{plane[1]}-position (m)')\n    ax.set_aspect('equal')\n\n    plt.tight_layout()\n\n    if save_path:\n        output_dir = os.path.dirname(save_path)\n        if output_dir and not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n        fig.savefig(save_path)\n        print(f\"Stream plot saved to {save_path}\")\n    if show:\n        plt.show()\n\n    plt.close(fig)\n</code></pre>"},{"location":"md/api/mag/#lib.MagSim.MagnetSensorSimulation.save_b_field","title":"<code>save_b_field(filepath, sensor_index=0)</code>","text":"<p>Save the magnetic field (B_field) data to a CSV file with x path positions in the first column.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to save the CSV file.</p> required <code>sensor_index</code> <code>int</code> <p>Index of the sensor to get magnetic field data for. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sensor_index is out of range.</p> Source code in <code>lib/MagSim.py</code> <pre><code>def save_b_field(self, filepath, sensor_index=0):\n    \"\"\"\n    Save the magnetic field (B_field) data to a CSV file with x path positions in the first column.\n\n    Args:\n        filepath (str): Path to save the CSV file.\n        sensor_index (int, optional): Index of the sensor to get magnetic field data for. Defaults to 0.\n\n    Raises:\n        IndexError: If the sensor_index is out of range.\n    \"\"\"\n    if sensor_index &gt;= len(self.sensors):\n        raise IndexError(f\"Sensor index {sensor_index} out of range.\")\n\n    B_field = self.get_magnetic_field_at_sensors(sensor_index)\n    x_positions = [pos[0] for pos in self.magnets[0].position]\n\n    data = {\n        \"x_position\": x_positions,\n        \"Bx\": B_field[:, 0],  # Magnetic field component in the x-direction\n        \"By\": B_field[:, 1],  # Magnetic field component in the y-direction\n        \"Bz\": B_field[:, 2],  # Magnetic field component in the z-direction\n    }\n\n    df = pd.DataFrame(data)\n    df.to_csv(filepath, index=False)\n    print(f\"B_field data saved to {filepath}\")\n</code></pre>"},{"location":"md/api/traj/","title":"Full Mechanism Simulation Handler","text":"<p>Handles the generation of sensor and magnet trajectories for a beam-based magnetic sensor simulation.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>class BeamSensorTrajectory:\n    \"\"\"Handles the generation of sensor and magnet trajectories for a beam-based magnetic sensor simulation.\"\"\"\n\n    def __init__(self, sensor_beam_config, magnet_beam_config, simulation, unit_conversion=0.001,\n                 frame_translation=None, sensor_rotation_angles=None, magnet_rotation_angles=None):\n        \"\"\"\n        Initializes the BeamSensorTrajectory class.\n\n        Args:\n            sensor_beam_config (dict or str): Beam configuration for the sensor, as a dict or YAML file path.\n            magnet_beam_config (dict or str): Beam configuration for the magnet, as a dict or YAML file path.\n            simulation (MagnetSensorSimulation): Simulation object for running the sensor and magnet simulation.\n            unit_conversion (float, optional): Unit conversion factor from mm to meters. Defaults to 0.001.\n            frame_translation (list of float, optional): 3D translation to apply between beam and magnet simulation.\n                Defaults to None.\n            sensor_rotation_angles (list of float, optional): Rotation angles (Euler angles) for the sensor in degrees.\n                Defaults to [0, 90, 0].\n            magnet_rotation_angles (list of float, optional): Rotation angles (Euler angles) for the magnet in degrees.\n                Defaults to [0, 90, 90].\n        \"\"\"\n\n        # Check if sensor_beam_config is a dictionary or a YAML file path\n        if isinstance(sensor_beam_config, dict):\n            # Initialize using dictionaries\n            self.sensor_beam_solver = VonKarmanBeamSolver(**sensor_beam_config)\n        else:\n            self.sensor_beam_solver = VonKarmanBeamSolver.from_yaml(sensor_beam_config)\n\n        # Check if magnet_beam_config is a dictionary or a YAML file path\n        if isinstance(magnet_beam_config, dict):\n            # Initialize using dictionaries\n            self.magnet_beam_solver = VonKarmanBeamSolver(**magnet_beam_config)\n        else:\n            self.magnet_beam_solver = VonKarmanBeamSolver.from_yaml(magnet_beam_config)\n\n        # Initialize and solve the beam models for the sensor and magnet\n        self.sensor_beam_solver.solve()\n        self.magnet_beam_solver.solve()\n\n        self.simulation = simulation\n        self.unit_conversion = unit_conversion\n        self.frame_translation = frame_translation if frame_translation is not None else [0, 0, 0]\n\n        sensor_rotation_angles = sensor_rotation_angles if sensor_rotation_angles is not None else [0, 90, 0]\n        self.sensor_rotation_matrix = R.from_euler('xyz', sensor_rotation_angles, degrees=True).as_matrix()\n\n        magnet_rotation_angles = magnet_rotation_angles if magnet_rotation_angles is not None else [0, 90, 90]\n        self.magnet_rotation_matrix = R.from_euler('xyz', magnet_rotation_angles, degrees=True).as_matrix()\n\n\n    def apply_translation(self, position):\n        \"\"\"\n        Applies frame translation to a given position.\n\n        Args:\n            position (list of float): Position vector.\n\n        Returns:\n            list of float: Translated position.\n        \"\"\"\n        return [position[0] + self.frame_translation[0], position[1] + self.frame_translation[1],\n                position[2] + self.frame_translation[2]]\n\n    def apply_rotation(self, position, rotation_matrix):\n        \"\"\"\n        Applies a given rotation matrix to the position.\n\n        Args:\n            position (list of float): Position vector.\n            rotation_matrix (np.ndarray): 3x3 rotation matrix.\n\n        Returns:\n            np.ndarray: Rotated position vector.\n        \"\"\"\n        return np.dot(rotation_matrix, position)\n\n    def create_sensor_trajectory(self):\n        \"\"\"\n        Generates sensor trajectory based on the last elements of each solution from the sensor beam deformation.\n\n        Returns:\n            tuple: (sensor_positions, sensor_orientations) - Lists of sensor positions and orientations.\n        \"\"\"\n        sensor_positions = []\n        sensor_orientations = []\n\n        for solution in self.sensor_beam_solver.solutions:\n            x_final = solution.t[-1]  # Last value of x\n            w_final = solution.y[0][-1]  # Last value of vertical deflection (w)\n            u_final = solution.y[2][-1]  # Last value of horizontal displacement (u)\n            slope_final = solution.y[1][-1]  # Last value of slope (dw/dx)\n            angle_final = np.degrees(slope_final)\n\n            x_meters = x_final * self.unit_conversion\n            u_meters = u_final * self.unit_conversion\n            w_meters = w_final * self.unit_conversion\n\n            position = [x_meters, u_meters, w_meters]\n            rotated_position = self.apply_rotation(position, self.sensor_rotation_matrix)\n            translated_position = self.apply_translation(rotated_position)\n            sensor_positions.append(translated_position)\n\n            orientation = [0, 0, np.radians(angle_final)]\n            sensor_orientations.append(orientation)\n\n        return sensor_positions, sensor_orientations\n\n    def create_magnet_trajectory(self):\n        \"\"\"\n        Generates magnet trajectory based on the magnet beam solver.\n\n        Returns:\n            tuple: (magnet_positions, magnet_orientations) - Lists of magnet positions and orientations.\n        \"\"\"\n        magnet_positions = []\n        magnet_orientations = []\n\n        for solution in self.magnet_beam_solver.solutions:\n            x_final = solution.t[-1]  # Last value of x\n            w_final = solution.y[0][-1]  # Last value of vertical deflection (w)\n            u_final = solution.y[2][-1]  # Last value of horizontal displacement (u)\n            slope_final = solution.y[1][-1]  # Last value of slope (dw/dx)\n\n            x_meters = x_final * self.unit_conversion\n            u_meters = u_final * self.unit_conversion\n            w_meters = w_final * self.unit_conversion\n\n            position = [x_meters, u_meters, w_meters]\n            rotated_position = self.apply_rotation(position, self.magnet_rotation_matrix)\n            translated_position = self.apply_translation(rotated_position)\n            magnet_positions.append(translated_position)\n\n            orientation = [0, 0, np.radians(np.degrees(slope_final))]\n            magnet_orientations.append(orientation)\n\n        return magnet_positions, magnet_orientations\n\n    def apply_sensor_trajectory(self):\n        \"\"\"Applies the generated sensor trajectory to the simulation.\"\"\"\n        sensor_positions, sensor_orientations = self.create_sensor_trajectory()\n        self.simulation.set_sensor_path(sensor_positions, sensor_orientations)\n\n    def apply_magnet_trajectory(self):\n        \"\"\"Applies the generated magnet trajectory to the simulation.\"\"\"\n        magnet_positions, magnet_orientations = self.create_magnet_trajectory()\n        self.simulation.set_magnet_path(magnet_positions, magnet_orientations)\n\n    def plot_trajectories_2d(self, sensor_positions, magnet_positions, sensor_orientations, magnet_orientations,\n                             file_path=None, show=True):\n        \"\"\"\n        Creates a Plotly 2D subplot showing movement (x, y, z) and angle for both the sensor and magnet.\n\n        Args:\n            sensor_positions (list): List of sensor positions.\n            magnet_positions (list): List of magnet positions.\n            sensor_orientations (list): List of sensor orientations.\n            magnet_orientations (list): List of magnet orientations.\n            file_path (str, optional): Path to save the plot. Defaults to None.\n            show (bool, optional): Whether to display the plot. Defaults to True.\n\n        Returns:\n            plotly.graph_objects.Figure: The generated figure.\n        \"\"\"\n        fig = make_subplots(rows=2, cols=2,\n                            subplot_titles=(\"Sensor Position\", \"Sensor Angle\", \"Magnet Position\", \"Magnet Angle\"))\n\n        time = list(range(len(sensor_positions)))\n\n        # Sensor positions (x, y, z)\n        sensor_x, sensor_y, sensor_z = zip(\n            *[(p[0] * 1e3, p[1] * 1e3, p[2] * 1e3) for p in sensor_positions])  # Convert to mm\n        fig.add_trace(go.Scatter(x=time, y=sensor_x, mode='lines', name='Sensor X (mm)'), row=1, col=1)\n        fig.add_trace(go.Scatter(x=time, y=sensor_y, mode='lines', name='Sensor Y (mm)'), row=1, col=1)\n        fig.add_trace(go.Scatter(x=time, y=sensor_z, mode='lines', name='Sensor Z (mm)'), row=1, col=1)\n\n        # Sensor angles\n        sensor_angles = [np.degrees(o[2]) for o in sensor_orientations]\n        fig.add_trace(go.Scatter(x=time, y=sensor_angles, mode='lines', name='Sensor Angle (degrees)'), row=1, col=2)\n\n        # Magnet positions\n        magnet_x, magnet_y, magnet_z = zip(*[(p[0] * 1e3, p[1] * 1e3, p[2] * 1e3) for p in magnet_positions])\n        fig.add_trace(go.Scatter(x=time, y=magnet_x, mode='lines', name='Magnet X (mm)'), row=2, col=1)\n        fig.add_trace(go.Scatter(x=time, y=magnet_y, mode='lines', name='Magnet Y (mm)'), row=2, col=1)\n        fig.add_trace(go.Scatter(x=time, y=magnet_z, mode='lines', name='Magnet Z (mm)'), row=2, col=1)\n\n        # Magnet angles\n        magnet_angles = [np.degrees(o[2]) for o in magnet_orientations]  # Assuming z-rotation\n        fig.add_trace(go.Scatter(x=time, y=magnet_angles, mode='lines', name='Magnet Angle (degrees)'), row=2, col=2)\n\n        # Layout settings\n        fig.update_layout(height=800, width=1000, title_text=\"Sensor and Magnet Movement and Angles Over Time\")\n        fig.update_xaxes(title_text=\"Time\", row=1, col=1)\n        fig.update_xaxes(title_text=\"Time\", row=1, col=2)\n        fig.update_xaxes(title_text=\"Time\", row=2, col=1)\n        fig.update_xaxes(title_text=\"Time\", row=2, col=2)\n        fig.update_yaxes(title_text=\"Position (mm)\", row=1, col=1)\n        fig.update_yaxes(title_text=\"Angle (degrees)\", row=1, col=2)\n        fig.update_yaxes(title_text=\"Position (mm)\", row=2, col=1)\n        fig.update_yaxes(title_text=\"Angle (degrees)\", row=2, col=2)\n        if file_path is not None:\n            fig.write_html(file_path)\n        if show:\n            fig.show()\n        return fig\n\n    def save_results_to_csv(self, sensor_positions, sensor_orientations, magnet_positions, magnet_orientations,\n                            file_name=\"combined_data.csv\", return_data=False):\n        \"\"\"\n        Saves sensor and magnet positions, orientations, and magnetic field data to a CSV file or returns a DataFrame.\n\n        Args:\n            sensor_positions (list): List of sensor positions.\n            sensor_orientations (list): List of sensor orientations.\n            magnet_positions (list): List of magnet positions.\n            magnet_orientations (list): List of magnet orientations.\n            file_name (str, optional): Name of the CSV file. Defaults to \"combined_data.csv\".\n            return_data (bool, optional): Whether to return the data as a DataFrame instead of saving it. Defaults to False.\n\n        Returns:\n            pandas.DataFrame: DataFrame with combined data if return_data is True, otherwise None.\n        \"\"\"\n        sensor_data = {'Time': list(range(len(sensor_positions))), 'Sensor_X (m)': [p[0] for p in sensor_positions],\n            'Sensor_Y (m)': [p[1] for p in sensor_positions], 'Sensor_Z (m)': [p[2] for p in sensor_positions],\n            'Sensor_Orientation_Z (rad)': [o[2] for o in sensor_orientations]}\n\n        magnet_data = {'Magnet_X (m)': [p[0] for p in magnet_positions],\n            'Magnet_Y (m)': [p[1] for p in magnet_positions], 'Magnet_Z (m)': [p[2] for p in magnet_positions],\n            'Magnet_Orientation_Z (rad)': [o[2] for o in magnet_orientations]}\n\n        B_values = self.simulation.get_magnetic_field_at_sensors(0)\n        magnetic_field_data = {'Bx (T)': [B[0] for B in B_values], 'By (T)': [B[1] for B in B_values],\n            'Bz (T)': [B[2] for B in B_values]}\n\n        combined_data = {**sensor_data, **magnet_data, **magnetic_field_data}\n\n        combined_df = pd.DataFrame(combined_data)\n\n        if return_data:\n            return combined_df\n\n        output_dir = os.path.dirname(file_name)\n        if output_dir and not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n\n        if not file_name.endswith(\".csv\"):\n            file_name += \".csv\"\n\n            combined_df.to_csv(file_name, index=False)\n            print(f\"Combined data saved to {file_name}\")\n        return None\n\n    def compute_sensitivity(self, applied_forces, file_path=None, show=True):\n        \"\"\"\n        Computes the sensitivity (gradient of B-field components with respect to force) and plots sensitivity vs. force.\n\n        Args:\n            applied_forces (list): List of applied forces.\n            file_path (str, optional): Path to save the plot. Defaults to None.\n            show (bool, optional): Whether to display the plot. Defaults to True.\n\n        Returns:\n            tuple: Sensitivity of Bx, By, Bz (in G/N), and the force corresponding to max(abs(Bx)).\n        \"\"\"\n        B_values = self.simulation.get_magnetic_field_at_sensors()\n        Bx_values = np.array([B[0] for B in B_values]) * 1e4\n        By_values = np.array([B[1] for B in B_values]) * 1e4\n        Bz_values = np.array([B[2] for B in B_values]) * 1e4\n\n        applied_forces_N = np.insert(np.array(applied_forces), 0, 0)\n\n        # Compute the gradient of B-field components with respect to the applied force\n        sensitivity_Bx = np.gradient(Bx_values, applied_forces_N)  # dBx/dF in G/N\n        sensitivity_By = np.gradient(By_values, applied_forces_N)  # dBy/dF in G/N\n        sensitivity_Bz = np.gradient(Bz_values, applied_forces_N)  # dBz/dF in G/N\n\n        max_abs_Bx_index = np.argmax(np.abs(Bx_values))\n        max_force = applied_forces_N[max_abs_Bx_index]\n        print(f\"The maximum applied force corresponding to max(abs(Bx)) is: {max_force} N\")\n\n        if file_path is not None:\n            with open('max_force.txt', 'w') as f:\n                f.write(f\"The maximum applied force corresponding to max(abs(Bx)) is: {max_force} N\\n\")\n\n        fig_sensitivity = go.Figure()\n        fig_sensitivity.add_trace(go.Scatter(x=applied_forces_N, y=sensitivity_Bx, mode='lines', name='dBx/dF (G/N)'))\n        fig_sensitivity.add_trace(go.Scatter(x=applied_forces_N, y=sensitivity_By, mode='lines', name='dBy/dF (G/N)'))\n        fig_sensitivity.add_trace(go.Scatter(x=applied_forces_N, y=sensitivity_Bz, mode='lines', name='dBz/dF (G/N)'))\n        fig_sensitivity.update_layout(title='Sensitivity (dB/dF) over Applied Force', xaxis_title='Applied Force (N)',\n                                      yaxis_title='Sensitivity (G/N)')\n        if file_path is not None:\n            fig_sensitivity.write_html(file_path)\n        if show:\n            fig_sensitivity.show()\n\n        # Return the sensitivity data and max force\n        return sensitivity_Bx, sensitivity_By, sensitivity_Bz, max_force\n\n\n    def run_simulation(self, save_as=None, return_data=False):\n        \"\"\"\n        Runs the full sensor and magnet simulation and optionally returns the data.\n\n        Args:\n            save_as (str, optional): File path to save the results. Defaults to None.\n            return_data (bool, optional): Whether to return the data as a DataFrame. Defaults to False.\n\n        Returns:\n            pandas.DataFrame: Data with sensitivity and safety factors, if return_data is True.\n        \"\"\"\n        sensor_positions, sensor_orientations = self.create_sensor_trajectory()\n        magnet_positions, magnet_orientations = self.create_magnet_trajectory()\n\n\n        self.simulation.set_sensor_path(sensor_positions, sensor_orientations)\n        self.simulation.set_magnet_path(magnet_positions, magnet_orientations)\n\n        # Animate and display the sensor and magnet movement\n        fig = self.simulation.display_with_outputs(animation=True, backend=\"plotly\", show=False)\n\n        # Compute sensitivity\n        sensitivity_Bx, sensitivity_By, sensitivity_Bz, max_force = self.compute_sensitivity(self.sensor_beam_solver.applied_force, show=False)\n        yield_safety_factor = self.sensor_beam_solver.safety_factors_yield[-1]\n        fatigue_safety_factor = self.sensor_beam_solver.safety_factors_fatigue[-1]\n        force_below_yield_sf = self.sensor_beam_solver.force_below_yield_sf\n        force_below_fatigue_sf = self.sensor_beam_solver.force_below_fatigue_sf\n\n        if return_data:\n            data = self.save_results_to_csv(sensor_positions, sensor_orientations, magnet_positions, magnet_orientations,\n                                        return_data=True)\n            data['sensitivity_Bx (G/N)'] = sensitivity_Bx\n            data['sensitivity_By (G/N)'] = sensitivity_By\n            data['sensitivity_Bz (G/N)'] = sensitivity_Bz\n            data['max_force (N)'] = max_force\n            data['yield_safety_factor'] = yield_safety_factor\n            data['fatigue_safety_factor'] = fatigue_safety_factor\n            data['force_below_yield_sf (N)'] = force_below_yield_sf\n            data['force_below_fatigue_sf (N)'] = force_below_fatigue_sf\n\n            return data\n\n        if save_as:\n            sensitivity_plot_file = save_as if save_as.endswith('.html') else save_as + '_sensitivity.html'\n            self.compute_sensitivity(self.sensor_beam_solver.applied_force, file_path=sensitivity_plot_file)\n            svg_file = save_as if save_as.endswith('.svg') else save_as + '.svg'\n            self.simulation.stream_plot(plane=\"XZ\", plane_limits=(-0.01, 0.01), resolution=100, timestep=-1,\n                                        save_path=svg_file)\n        else:\n            self.plot_trajectories_2d(sensor_positions, magnet_positions, sensor_orientations, magnet_orientations)\n            self.compute_sensitivity(self.sensor_beam_solver.applied_force)\n\n        return None\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.apply_translation","title":"<code>apply_translation(position)</code>","text":"<p>Applies frame translation to a given position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>list of float</code> <p>Position vector.</p> required <p>Returns:</p> Type Description <p>list of float: Translated position.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def apply_translation(self, position):\n    \"\"\"\n    Applies frame translation to a given position.\n\n    Args:\n        position (list of float): Position vector.\n\n    Returns:\n        list of float: Translated position.\n    \"\"\"\n    return [position[0] + self.frame_translation[0], position[1] + self.frame_translation[1],\n            position[2] + self.frame_translation[2]]\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.apply_rotation","title":"<code>apply_rotation(position, rotation_matrix)</code>","text":"<p>Applies a given rotation matrix to the position.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>list of float</code> <p>Position vector.</p> required <code>rotation_matrix</code> <code>ndarray</code> <p>3x3 rotation matrix.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Rotated position vector.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def apply_rotation(self, position, rotation_matrix):\n    \"\"\"\n    Applies a given rotation matrix to the position.\n\n    Args:\n        position (list of float): Position vector.\n        rotation_matrix (np.ndarray): 3x3 rotation matrix.\n\n    Returns:\n        np.ndarray: Rotated position vector.\n    \"\"\"\n    return np.dot(rotation_matrix, position)\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.create_sensor_trajectory","title":"<code>create_sensor_trajectory()</code>","text":"<p>Generates sensor trajectory based on the last elements of each solution from the sensor beam deformation.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(sensor_positions, sensor_orientations) - Lists of sensor positions and orientations.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def create_sensor_trajectory(self):\n    \"\"\"\n    Generates sensor trajectory based on the last elements of each solution from the sensor beam deformation.\n\n    Returns:\n        tuple: (sensor_positions, sensor_orientations) - Lists of sensor positions and orientations.\n    \"\"\"\n    sensor_positions = []\n    sensor_orientations = []\n\n    for solution in self.sensor_beam_solver.solutions:\n        x_final = solution.t[-1]  # Last value of x\n        w_final = solution.y[0][-1]  # Last value of vertical deflection (w)\n        u_final = solution.y[2][-1]  # Last value of horizontal displacement (u)\n        slope_final = solution.y[1][-1]  # Last value of slope (dw/dx)\n        angle_final = np.degrees(slope_final)\n\n        x_meters = x_final * self.unit_conversion\n        u_meters = u_final * self.unit_conversion\n        w_meters = w_final * self.unit_conversion\n\n        position = [x_meters, u_meters, w_meters]\n        rotated_position = self.apply_rotation(position, self.sensor_rotation_matrix)\n        translated_position = self.apply_translation(rotated_position)\n        sensor_positions.append(translated_position)\n\n        orientation = [0, 0, np.radians(angle_final)]\n        sensor_orientations.append(orientation)\n\n    return sensor_positions, sensor_orientations\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.create_magnet_trajectory","title":"<code>create_magnet_trajectory()</code>","text":"<p>Generates magnet trajectory based on the magnet beam solver.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(magnet_positions, magnet_orientations) - Lists of magnet positions and orientations.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def create_magnet_trajectory(self):\n    \"\"\"\n    Generates magnet trajectory based on the magnet beam solver.\n\n    Returns:\n        tuple: (magnet_positions, magnet_orientations) - Lists of magnet positions and orientations.\n    \"\"\"\n    magnet_positions = []\n    magnet_orientations = []\n\n    for solution in self.magnet_beam_solver.solutions:\n        x_final = solution.t[-1]  # Last value of x\n        w_final = solution.y[0][-1]  # Last value of vertical deflection (w)\n        u_final = solution.y[2][-1]  # Last value of horizontal displacement (u)\n        slope_final = solution.y[1][-1]  # Last value of slope (dw/dx)\n\n        x_meters = x_final * self.unit_conversion\n        u_meters = u_final * self.unit_conversion\n        w_meters = w_final * self.unit_conversion\n\n        position = [x_meters, u_meters, w_meters]\n        rotated_position = self.apply_rotation(position, self.magnet_rotation_matrix)\n        translated_position = self.apply_translation(rotated_position)\n        magnet_positions.append(translated_position)\n\n        orientation = [0, 0, np.radians(np.degrees(slope_final))]\n        magnet_orientations.append(orientation)\n\n    return magnet_positions, magnet_orientations\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.apply_sensor_trajectory","title":"<code>apply_sensor_trajectory()</code>","text":"<p>Applies the generated sensor trajectory to the simulation.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def apply_sensor_trajectory(self):\n    \"\"\"Applies the generated sensor trajectory to the simulation.\"\"\"\n    sensor_positions, sensor_orientations = self.create_sensor_trajectory()\n    self.simulation.set_sensor_path(sensor_positions, sensor_orientations)\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.apply_magnet_trajectory","title":"<code>apply_magnet_trajectory()</code>","text":"<p>Applies the generated magnet trajectory to the simulation.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def apply_magnet_trajectory(self):\n    \"\"\"Applies the generated magnet trajectory to the simulation.\"\"\"\n    magnet_positions, magnet_orientations = self.create_magnet_trajectory()\n    self.simulation.set_magnet_path(magnet_positions, magnet_orientations)\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.plot_trajectories_2d","title":"<code>plot_trajectories_2d(sensor_positions, magnet_positions, sensor_orientations, magnet_orientations, file_path=None, show=True)</code>","text":"<p>Creates a Plotly 2D subplot showing movement (x, y, z) and angle for both the sensor and magnet.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_positions</code> <code>list</code> <p>List of sensor positions.</p> required <code>magnet_positions</code> <code>list</code> <p>List of magnet positions.</p> required <code>sensor_orientations</code> <code>list</code> <p>List of sensor orientations.</p> required <code>magnet_orientations</code> <code>list</code> <p>List of magnet orientations.</p> required <code>file_path</code> <code>str</code> <p>Path to save the plot. Defaults to None.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>plotly.graph_objects.Figure: The generated figure.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def plot_trajectories_2d(self, sensor_positions, magnet_positions, sensor_orientations, magnet_orientations,\n                         file_path=None, show=True):\n    \"\"\"\n    Creates a Plotly 2D subplot showing movement (x, y, z) and angle for both the sensor and magnet.\n\n    Args:\n        sensor_positions (list): List of sensor positions.\n        magnet_positions (list): List of magnet positions.\n        sensor_orientations (list): List of sensor orientations.\n        magnet_orientations (list): List of magnet orientations.\n        file_path (str, optional): Path to save the plot. Defaults to None.\n        show (bool, optional): Whether to display the plot. Defaults to True.\n\n    Returns:\n        plotly.graph_objects.Figure: The generated figure.\n    \"\"\"\n    fig = make_subplots(rows=2, cols=2,\n                        subplot_titles=(\"Sensor Position\", \"Sensor Angle\", \"Magnet Position\", \"Magnet Angle\"))\n\n    time = list(range(len(sensor_positions)))\n\n    # Sensor positions (x, y, z)\n    sensor_x, sensor_y, sensor_z = zip(\n        *[(p[0] * 1e3, p[1] * 1e3, p[2] * 1e3) for p in sensor_positions])  # Convert to mm\n    fig.add_trace(go.Scatter(x=time, y=sensor_x, mode='lines', name='Sensor X (mm)'), row=1, col=1)\n    fig.add_trace(go.Scatter(x=time, y=sensor_y, mode='lines', name='Sensor Y (mm)'), row=1, col=1)\n    fig.add_trace(go.Scatter(x=time, y=sensor_z, mode='lines', name='Sensor Z (mm)'), row=1, col=1)\n\n    # Sensor angles\n    sensor_angles = [np.degrees(o[2]) for o in sensor_orientations]\n    fig.add_trace(go.Scatter(x=time, y=sensor_angles, mode='lines', name='Sensor Angle (degrees)'), row=1, col=2)\n\n    # Magnet positions\n    magnet_x, magnet_y, magnet_z = zip(*[(p[0] * 1e3, p[1] * 1e3, p[2] * 1e3) for p in magnet_positions])\n    fig.add_trace(go.Scatter(x=time, y=magnet_x, mode='lines', name='Magnet X (mm)'), row=2, col=1)\n    fig.add_trace(go.Scatter(x=time, y=magnet_y, mode='lines', name='Magnet Y (mm)'), row=2, col=1)\n    fig.add_trace(go.Scatter(x=time, y=magnet_z, mode='lines', name='Magnet Z (mm)'), row=2, col=1)\n\n    # Magnet angles\n    magnet_angles = [np.degrees(o[2]) for o in magnet_orientations]  # Assuming z-rotation\n    fig.add_trace(go.Scatter(x=time, y=magnet_angles, mode='lines', name='Magnet Angle (degrees)'), row=2, col=2)\n\n    # Layout settings\n    fig.update_layout(height=800, width=1000, title_text=\"Sensor and Magnet Movement and Angles Over Time\")\n    fig.update_xaxes(title_text=\"Time\", row=1, col=1)\n    fig.update_xaxes(title_text=\"Time\", row=1, col=2)\n    fig.update_xaxes(title_text=\"Time\", row=2, col=1)\n    fig.update_xaxes(title_text=\"Time\", row=2, col=2)\n    fig.update_yaxes(title_text=\"Position (mm)\", row=1, col=1)\n    fig.update_yaxes(title_text=\"Angle (degrees)\", row=1, col=2)\n    fig.update_yaxes(title_text=\"Position (mm)\", row=2, col=1)\n    fig.update_yaxes(title_text=\"Angle (degrees)\", row=2, col=2)\n    if file_path is not None:\n        fig.write_html(file_path)\n    if show:\n        fig.show()\n    return fig\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.save_results_to_csv","title":"<code>save_results_to_csv(sensor_positions, sensor_orientations, magnet_positions, magnet_orientations, file_name='combined_data.csv', return_data=False)</code>","text":"<p>Saves sensor and magnet positions, orientations, and magnetic field data to a CSV file or returns a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_positions</code> <code>list</code> <p>List of sensor positions.</p> required <code>sensor_orientations</code> <code>list</code> <p>List of sensor orientations.</p> required <code>magnet_positions</code> <code>list</code> <p>List of magnet positions.</p> required <code>magnet_orientations</code> <code>list</code> <p>List of magnet orientations.</p> required <code>file_name</code> <code>str</code> <p>Name of the CSV file. Defaults to \"combined_data.csv\".</p> <code>'combined_data.csv'</code> <code>return_data</code> <code>bool</code> <p>Whether to return the data as a DataFrame instead of saving it. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>pandas.DataFrame: DataFrame with combined data if return_data is True, otherwise None.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def save_results_to_csv(self, sensor_positions, sensor_orientations, magnet_positions, magnet_orientations,\n                        file_name=\"combined_data.csv\", return_data=False):\n    \"\"\"\n    Saves sensor and magnet positions, orientations, and magnetic field data to a CSV file or returns a DataFrame.\n\n    Args:\n        sensor_positions (list): List of sensor positions.\n        sensor_orientations (list): List of sensor orientations.\n        magnet_positions (list): List of magnet positions.\n        magnet_orientations (list): List of magnet orientations.\n        file_name (str, optional): Name of the CSV file. Defaults to \"combined_data.csv\".\n        return_data (bool, optional): Whether to return the data as a DataFrame instead of saving it. Defaults to False.\n\n    Returns:\n        pandas.DataFrame: DataFrame with combined data if return_data is True, otherwise None.\n    \"\"\"\n    sensor_data = {'Time': list(range(len(sensor_positions))), 'Sensor_X (m)': [p[0] for p in sensor_positions],\n        'Sensor_Y (m)': [p[1] for p in sensor_positions], 'Sensor_Z (m)': [p[2] for p in sensor_positions],\n        'Sensor_Orientation_Z (rad)': [o[2] for o in sensor_orientations]}\n\n    magnet_data = {'Magnet_X (m)': [p[0] for p in magnet_positions],\n        'Magnet_Y (m)': [p[1] for p in magnet_positions], 'Magnet_Z (m)': [p[2] for p in magnet_positions],\n        'Magnet_Orientation_Z (rad)': [o[2] for o in magnet_orientations]}\n\n    B_values = self.simulation.get_magnetic_field_at_sensors(0)\n    magnetic_field_data = {'Bx (T)': [B[0] for B in B_values], 'By (T)': [B[1] for B in B_values],\n        'Bz (T)': [B[2] for B in B_values]}\n\n    combined_data = {**sensor_data, **magnet_data, **magnetic_field_data}\n\n    combined_df = pd.DataFrame(combined_data)\n\n    if return_data:\n        return combined_df\n\n    output_dir = os.path.dirname(file_name)\n    if output_dir and not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n\n    if not file_name.endswith(\".csv\"):\n        file_name += \".csv\"\n\n        combined_df.to_csv(file_name, index=False)\n        print(f\"Combined data saved to {file_name}\")\n    return None\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.compute_sensitivity","title":"<code>compute_sensitivity(applied_forces, file_path=None, show=True)</code>","text":"<p>Computes the sensitivity (gradient of B-field components with respect to force) and plots sensitivity vs. force.</p> <p>Parameters:</p> Name Type Description Default <code>applied_forces</code> <code>list</code> <p>List of applied forces.</p> required <code>file_path</code> <code>str</code> <p>Path to save the plot. Defaults to None.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Sensitivity of Bx, By, Bz (in G/N), and the force corresponding to max(abs(Bx)).</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def compute_sensitivity(self, applied_forces, file_path=None, show=True):\n    \"\"\"\n    Computes the sensitivity (gradient of B-field components with respect to force) and plots sensitivity vs. force.\n\n    Args:\n        applied_forces (list): List of applied forces.\n        file_path (str, optional): Path to save the plot. Defaults to None.\n        show (bool, optional): Whether to display the plot. Defaults to True.\n\n    Returns:\n        tuple: Sensitivity of Bx, By, Bz (in G/N), and the force corresponding to max(abs(Bx)).\n    \"\"\"\n    B_values = self.simulation.get_magnetic_field_at_sensors()\n    Bx_values = np.array([B[0] for B in B_values]) * 1e4\n    By_values = np.array([B[1] for B in B_values]) * 1e4\n    Bz_values = np.array([B[2] for B in B_values]) * 1e4\n\n    applied_forces_N = np.insert(np.array(applied_forces), 0, 0)\n\n    # Compute the gradient of B-field components with respect to the applied force\n    sensitivity_Bx = np.gradient(Bx_values, applied_forces_N)  # dBx/dF in G/N\n    sensitivity_By = np.gradient(By_values, applied_forces_N)  # dBy/dF in G/N\n    sensitivity_Bz = np.gradient(Bz_values, applied_forces_N)  # dBz/dF in G/N\n\n    max_abs_Bx_index = np.argmax(np.abs(Bx_values))\n    max_force = applied_forces_N[max_abs_Bx_index]\n    print(f\"The maximum applied force corresponding to max(abs(Bx)) is: {max_force} N\")\n\n    if file_path is not None:\n        with open('max_force.txt', 'w') as f:\n            f.write(f\"The maximum applied force corresponding to max(abs(Bx)) is: {max_force} N\\n\")\n\n    fig_sensitivity = go.Figure()\n    fig_sensitivity.add_trace(go.Scatter(x=applied_forces_N, y=sensitivity_Bx, mode='lines', name='dBx/dF (G/N)'))\n    fig_sensitivity.add_trace(go.Scatter(x=applied_forces_N, y=sensitivity_By, mode='lines', name='dBy/dF (G/N)'))\n    fig_sensitivity.add_trace(go.Scatter(x=applied_forces_N, y=sensitivity_Bz, mode='lines', name='dBz/dF (G/N)'))\n    fig_sensitivity.update_layout(title='Sensitivity (dB/dF) over Applied Force', xaxis_title='Applied Force (N)',\n                                  yaxis_title='Sensitivity (G/N)')\n    if file_path is not None:\n        fig_sensitivity.write_html(file_path)\n    if show:\n        fig_sensitivity.show()\n\n    # Return the sensitivity data and max force\n    return sensitivity_Bx, sensitivity_By, sensitivity_Bz, max_force\n</code></pre>"},{"location":"md/api/traj/#lib.BeamMagSim.BeamSensorTrajectory.run_simulation","title":"<code>run_simulation(save_as=None, return_data=False)</code>","text":"<p>Runs the full sensor and magnet simulation and optionally returns the data.</p> <p>Parameters:</p> Name Type Description Default <code>save_as</code> <code>str</code> <p>File path to save the results. Defaults to None.</p> <code>None</code> <code>return_data</code> <code>bool</code> <p>Whether to return the data as a DataFrame. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>pandas.DataFrame: Data with sensitivity and safety factors, if return_data is True.</p> Source code in <code>lib/BeamMagSim.py</code> <pre><code>def run_simulation(self, save_as=None, return_data=False):\n    \"\"\"\n    Runs the full sensor and magnet simulation and optionally returns the data.\n\n    Args:\n        save_as (str, optional): File path to save the results. Defaults to None.\n        return_data (bool, optional): Whether to return the data as a DataFrame. Defaults to False.\n\n    Returns:\n        pandas.DataFrame: Data with sensitivity and safety factors, if return_data is True.\n    \"\"\"\n    sensor_positions, sensor_orientations = self.create_sensor_trajectory()\n    magnet_positions, magnet_orientations = self.create_magnet_trajectory()\n\n\n    self.simulation.set_sensor_path(sensor_positions, sensor_orientations)\n    self.simulation.set_magnet_path(magnet_positions, magnet_orientations)\n\n    # Animate and display the sensor and magnet movement\n    fig = self.simulation.display_with_outputs(animation=True, backend=\"plotly\", show=False)\n\n    # Compute sensitivity\n    sensitivity_Bx, sensitivity_By, sensitivity_Bz, max_force = self.compute_sensitivity(self.sensor_beam_solver.applied_force, show=False)\n    yield_safety_factor = self.sensor_beam_solver.safety_factors_yield[-1]\n    fatigue_safety_factor = self.sensor_beam_solver.safety_factors_fatigue[-1]\n    force_below_yield_sf = self.sensor_beam_solver.force_below_yield_sf\n    force_below_fatigue_sf = self.sensor_beam_solver.force_below_fatigue_sf\n\n    if return_data:\n        data = self.save_results_to_csv(sensor_positions, sensor_orientations, magnet_positions, magnet_orientations,\n                                    return_data=True)\n        data['sensitivity_Bx (G/N)'] = sensitivity_Bx\n        data['sensitivity_By (G/N)'] = sensitivity_By\n        data['sensitivity_Bz (G/N)'] = sensitivity_Bz\n        data['max_force (N)'] = max_force\n        data['yield_safety_factor'] = yield_safety_factor\n        data['fatigue_safety_factor'] = fatigue_safety_factor\n        data['force_below_yield_sf (N)'] = force_below_yield_sf\n        data['force_below_fatigue_sf (N)'] = force_below_fatigue_sf\n\n        return data\n\n    if save_as:\n        sensitivity_plot_file = save_as if save_as.endswith('.html') else save_as + '_sensitivity.html'\n        self.compute_sensitivity(self.sensor_beam_solver.applied_force, file_path=sensitivity_plot_file)\n        svg_file = save_as if save_as.endswith('.svg') else save_as + '.svg'\n        self.simulation.stream_plot(plane=\"XZ\", plane_limits=(-0.01, 0.01), resolution=100, timestep=-1,\n                                    save_path=svg_file)\n    else:\n        self.plot_trajectories_2d(sensor_positions, magnet_positions, sensor_orientations, magnet_orientations)\n        self.compute_sensitivity(self.sensor_beam_solver.applied_force)\n\n    return None\n</code></pre>"},{"location":"md/data/material/","title":"Material, Force Sensitivity and Range","text":""},{"location":"md/data/material/#sensible-force-range-and-force-sensitivity","title":"Sensible Force Range and Force Sensitivity","text":"<p>Note</p> <p>Sensible force range is limited by the flexure strength.</p> <p>By adjusting \\(\\Gamma_{\\mathcal{M}}\\) we can improve the range.</p> <p>i.e. reduce the range of deflection, but configure \\(\\Gamma_{\\mathcal{M}}\\) to detect smaller deflections</p>"},{"location":"md/data/material/#sweeping-parameters","title":"Sweeping Parameters","text":"<p>\\(\\Gamma_{b},\\Gamma_{\\mathcal{M}}\\)</p> <p>Here, we sweeped 5,000 different parameters per material, totaling 30,000 parameter combinations.</p> Parameter Values L (Length of beam) 10, 30, 50, 100 (mm) b (Width of beam) 5, 10 (mm) h (Thickness of beam) 1, 2, 5, 8, 10 (mm) magnet_D (Diameter of magnet) 0.001, 0.003, 0.005, 0.01, 0.02 (m) magnet_L (Length of magnet) 0.001, 0.003, 0.005, 0.01, 0.02 (m) magnet_distance (Distance from sensor) 0.001, 0.003, 0.005, 0.01, 0.015 (m)"},{"location":"md/data/material/#material-parameters","title":"Material Parameters","text":"Material Young's Modulus (E) (MPa) Poisson's Ratio Yield Strength (MPa) Fatigue Strength (MPa) Aluminum 69,000 0.33 276 96 Stainless Steel 200,000 0.30 520 240 Brass 100,000 0.34 200 100 PLA 3,500 0.36 60 30 ABS 2,100 0.35 40 20 Nylon 12 1,650 0.39 48 24 <p>Mostly from Engineering Toolbox</p>"},{"location":"md/mech/overall/","title":"Mechanisms and Designs","text":""},{"location":"md/mech/overall/#hardware-design","title":"Hardware Design","text":"<p>MAGPIE is designed with a parallel gripper that can transition between flat and line foot configurations, serving dual roles in grasping and locomotion. The design incorporates 8-axis force sensing using four 3-axis Hall effect sensors, each installed on compliant flexure mechanisms.</p>"},{"location":"md/mech/overall/#foot-and-finger-design","title":"Foot and Finger Design","text":"<p>The fingers of MAGPIE are designed to measure both ground reaction forces and grasping forces. The flexure mechanism allows for multi-axis force measurement by isolating different axes. The Hall effect sensors are positioned laterally for grasping force measurement, while the magnets are placed longitudinally to measure ground contact forces. This placement helps protect the sensors from high impact forces during landing, ensuring durability.</p>"},{"location":"md/mech/overall/#actuation-mechanisms","title":"Actuation Mechanisms","text":"<p>MAGPIE's actuation mechanism uses a crossed-roller linear rail system, actuated by a brushless DC (BLDC) motor. The gripper is driven by lead screws connected to the motor, distributing torque evenly. The lateral flexure mechanism is designed to be sensitive, while the longitudinal mechanism is protected once the gripper is closed.</p>"},{"location":"md/mech/overall/#circuitry-and-sensors","title":"Circuitry and Sensors","text":"<p>The electronics in MAGPIE are modular and integrate the sensors, actuators, and control systems. The system includes Hall effect sensors mounted on custom flexible PCBs, a BLDC motor, an IMU, and other components like a camera and display for future enhancements. This modular design minimizes wiring complexity and improves reliability.</p>"},{"location":"md/mech/overall/#force-sensing-mechanism","title":"Force Sensing Mechanism","text":"<p>The Hall effect sensors detect magnetic field changes caused by deflections in the flexure mechanisms. The magnet-sensor configuration allows for multi-axis force measurements, with the flexure beam isolating forces along different axes. By using cylindrical magnets, MAGPIE ensures consistent signal detection across both axes.</p> <p>The computational framework simulates the magnet\u2019s behavior under different deflections, optimizing the sensor placement and flexure design for accurate force sensing while considering potential interference.</p>"},{"location":"md/mech/overall/#gripper-and-foot-capabilities","title":"Gripper and Foot Capabilities","text":"<p>MAGPIE has a custom-designed direct-drive BLDC motor capable of achieving a nominal grasping force of 350 N and opening/closing speeds of 58.3 mm/sec. The design is robust enough to handle ground impact forces while providing precise grasping capabilities. The force-sensing mechanism allows MAGPIE to function as a stable foot while also providing tactile sensing for grasping.</p>"},{"location":"md/sim/beam/","title":"Beam Simulation","text":"<p>The flexure-based design of MAGPIE's sensing mechanism is simulated using Von K\u00e1rm\u00e1n beam theory to account for large deflections. This model is vital for predicting how the flexure will deform under applied forces.</p> <p>Mathematical Model:</p> <p>The vertical force balance (bending equation):</p> \\[ EI \\frac{d^4 w(x)}{dx^4} = q(x) - \\frac{d}{dx} \\left( N(x) \\frac{dw(x)}{dx} \\right) \\] <p>Where - \\(E I\\) is the flexural rigidity - \\(w(x)\\) is the vertical deflection - \\(N(x)\\) is the axial force - \\(q(x)\\) is the distributed transverse load</p> <p>For horizontal force balance (stretching equation):</p> \\[ \\frac{d}{d x}\\left(E A \\frac{d u(x)}{d x}\\right)=\\frac{1}{2} E I\\left(\\frac{d w(x)}{d x}\\right)^2 \\] <p>This model helps ensure that the flexure design can withstand large deformations without failure while maintaining accurate force sensing.</p>"},{"location":"md/sim/gru/","title":"GRU and GRBF Models for Force Estimation","text":"<p>The framework employs machine learning models to enhance the accuracy of force estimation and handle nonlinearity in sensor measurements:</p>"},{"location":"md/sim/gru/#grbf-gaussian-radial-basis-functions","title":"GRBF (Gaussian Radial Basis Functions)","text":"<p>An ideal model is generated using GRBF to estimate forces based on simulated sensor readings. This model assumes ideal conditions without accounting for real-world uncertainties like hysteresis and interference. However, this provides a very quick solutions for your sensor designs.  Further tuning, such as bias compensations can improve the mean force estimation error. </p> <p>Note</p> <p>GRBF is nonlinear model here. Linear interporation may work much faster if the sensitivity is designed to be a constant, aka linear force-sensor relationship.</p>"},{"location":"md/sim/gru/#gru-gated-recurrent-unit","title":"GRU (Gated Recurrent Unit)","text":"<p>To address real-world uncertainties, a GRU-based model is trained with hardware data. The GRU model takes sensor inputs and outputs both mean force estimates and their associated uncertainties. This is essential for detecting anomalies, such as interference from external magnetic fields.</p> <p></p>"},{"location":"md/sim/mag/","title":"Magnetic Simulation","text":"<p>The Hall effect sensors detect force through magnetic field changes caused by the motion of a nearby magnet. The sensitivity of the magnetic field changes with respect to sensor positioning is critical to the design.</p>"},{"location":"md/sim/mag/#magnetic-field-sensitivity","title":"Magnetic Field Sensitivity:","text":"<p>The magnetic sensitivity is modeled as:</p> \\[ \\mathcal{S}=\\frac{\\delta \\mathcal{B}}{\\delta X} \\] <p>Where: - \\(\\mathcal{B}\\) is the magnetic field strength - \\(X\\) is the relative distance between the sensor and magnet</p> <p></p>"},{"location":"md/sim/mag/#interference-analysis","title":"Interference Analysis","text":"<p>Magnetic sensors are highly sensitive to interference from external magnetic fields, such as those from neighboring magnets or nearby motors. The framework includes an analysis of possible interference sources: - Earth's Magnetic Field: Typically negligible due to the proximity of stronger magnets. - Neighboring Magnets: Nearby magnets, especially when the gripper is closed, can interfere with measurements. The framework designs the sensing mechanism to minimize this interference.</p> <p></p>"},{"location":"md/sim/overall/","title":"Computational Design Framework for MAGPIE","text":""},{"location":"md/sim/overall/#overview","title":"Overview","text":"<p>MAGPIE (Multi-modal Adaptive Gripper for multi-Pedal Impact-resilient End-effector) is designed to serve as both a foot and a gripper in limbed robotics. The end-effector integrates 8-axis force sensing, which is achieved through Hall effect sensors and compliant mechanisms, providing measurements for both ground contact and grasping forces.</p> <p>To optimize the design of MAGPIE's sensing mechanism, a computational design framework has been developed. This framework simulates various configurations of sensors, magnets, and flexures to achieve the desired force range, sensitivity, and robustness against interference.</p>"},{"location":"md/sim/overall/#framework-components","title":"Framework Components","text":"<p>The computational design framework is divided into several key components: beam simulation, magnetic simulation, and interference analysis. These components interact to generate an optimal design for the force sensing mechanism.</p> <p></p>"}]}